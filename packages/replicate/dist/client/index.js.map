{"version":3,"file":"index.js","names":["collection","schema","diff: SchemaDiff","lastSyncedAt: Date | null","proseFields: string[]","collection","cachedSessionClientId: string | null","result: Record<string, unknown>","content: XmlNodeJSON[]","result: XmlNodeJSON","result: XmlNodeJSON[]","node: XmlNodeJSON","attrs: Record<string, unknown>","persistence","persistenceFactory: DocPersistenceFactory | null","collection","promises: Promise<void>[]","result: Record<string, unknown>","documents: Record<string, unknown>[]","getLogTapeLogger","collection","resolver: () => void","actorResolver: () => void","ctx: CollectionContext","logger","timeoutId: ReturnType<typeof setTimeout> | null","retryTimeoutId: ReturnType<typeof setTimeout> | null","collection","logger","collection","cleanup","state: PresenceLifecycleState","heartbeatTimer: ReturnType<typeof setInterval> | null","throttleTimer: ReturnType<typeof setTimeout> | null","startTimeout: ReturnType<typeof setTimeout> | null","unsubscribeCursors: (() => void) | undefined","unsubscribeVisibility: (() => void) | undefined","unsubscribePageHide: (() => void) | undefined","flightStatus: FlightStatus","result: {\n\t\t\t\tuser?: string;\n\t\t\t\tprofile?: { name?: string; color?: string; avatar?: string };\n\t\t\t}","profile: { name?: string; color?: string; avatar?: string }","remote: UserIdentity[]","remoteState: Record<string, unknown>","collection","proseFields: string[]","utils: ConvexCollectionUtils<DataType>","presenceProvider: PresenceProvider | null","prose.isPending","prose.subscribePending","sessionCache: SessionInfo[]","sessionUnsubscribe: (() => void) | null","extensions: ConvexCollectionExtensions<DataType>","docPersistence: PersistenceProvider","ops: BoundReplicateOps<DataType>","persistence","resolvePersistenceReady: (() => void) | undefined","resolveOptimisticReady: (() => void) | undefined","material","deltas: Uint8Array[]","subscription: (() => void) | null","docs: DataType[]","toInsert: DataType[]","toUpsert: DataType[]","toDelete: DataType[]","ctx","persistence: Persistence | null","resolvedConfig: LazyCollectionConfig<T> | null","material: Materialized<T> | undefined","instance: Instance | null","collectionName: string | null","paginationState: PaginationState","executor: Executor","collection: string","ydoc: Y.Doc","onError?: (error: Error) => void","collection","db: OPSQLiteDatabase","instance: Promise<Persistence> | null","adapter: StorageAdapter","collection: string","ydoc: Y.Doc","collection","generateSalt","credential: PublicKeyCredential | null","assertion: PublicKeyCredential | null","inner: KeyValueStore","getKey: () => CryptoKey | null","innerStorage: Persistence","collection: string","ydoc: Y.Doc","encryptionKey: CryptoKey","encryptionKey: CryptoKey | null","idleTimer: ReturnType<typeof setTimeout> | null","state: EncryptionState","collection","encryptedPersistence: EncryptionPersistence | null","currentState: EncryptionManagerState","config: WebEncryptionConfig"],"sources":["../../src/client/migration.ts","../../src/client/validators.ts","../../src/client/errors.ts","../../src/client/services/seq.ts","../../src/client/services/session.ts","../../src/client/ops.ts","../../src/client/merge.ts","../../src/client/documents.ts","../../src/client/deltas.ts","../../src/shared/logger.ts","../../src/client/services/context.ts","../../src/client/services/sync.ts","../../src/client/prose.ts","../../src/client/services/presence.ts","../../src/client/collection.ts","../../src/client/identity.ts","../../src/client/persistence/memory.ts","../../src/client/persistence/sqlite/schema.ts","../../src/client/persistence/sqlite/native.ts","../../src/client/persistence/sqlite/web.ts","../../src/client/persistence/custom.ts","../../src/client/persistence/encrypted/webauthn.ts","../../src/client/persistence/encrypted/crypto.ts","../../src/client/persistence/encrypted/web.ts","../../src/client/persistence/encrypted/manager.ts","../../src/client/persistence/index.ts","../../src/client/index.ts"],"sourcesContent":["/**\n * Client Migration System\n *\n * Handles automatic client-side migrations based on schema diffs.\n * Runs SQLite migrations and Yjs document updates.\n */\n\nimport type { SchemaDiff, SchemaDiffOperation, VersionedSchema } from \"$/server/migration\";\nimport type { GenericValidator } from \"convex/values\";\nimport type { MigrationDatabase } from \"$/client/persistence/types\";\n\n// Re-export MigrationDatabase from types\nexport type { MigrationDatabase } from \"$/client/persistence/types\";\n\n// ─────────────────────────────────────────────────────────────────────────────\n// Migration Error Types\n// ─────────────────────────────────────────────────────────────────────────────\n\n/** Error codes for migration failures */\nexport type MigrationErrorCode = \"SCHEMA_MISMATCH\" | \"SQLITE_ERROR\" | \"YJS_ERROR\" | \"NETWORK_ERROR\";\n\n/** Error details for migration failures */\nexport interface MigrationError {\n\tcode: MigrationErrorCode;\n\tmessage: string;\n\tfromVersion: number;\n\ttoVersion: number;\n\toperation?: SchemaDiffOperation;\n}\n\n/** Context for migration error recovery */\nexport interface RecoveryContext {\n\terror: MigrationError;\n\t/** True if no unsynced local changes exist */\n\tcanResetSafely: boolean;\n\t/** Count of unsynced local changes */\n\tpendingChanges: number;\n\t/** Timestamp of last successful sync */\n\tlastSyncedAt: Date | null;\n}\n\n/** Available recovery actions */\nexport type RecoveryAction =\n\t| { action: \"reset\" }\n\t| { action: \"keep-old-schema\" }\n\t| { action: \"retry\" }\n\t| { action: \"custom\"; handler: () => Promise<void> };\n\n/** Handler for migration errors */\nexport type MigrationErrorHandler = (\n\terror: MigrationError,\n\tcontext: RecoveryContext,\n) => Promise<RecoveryAction>;\n\n/** Yjs document info for migrations */\nexport interface MigrationDoc {\n\tid: string;\n\tfields: Map<string, unknown>;\n}\n\n/** Context for custom client migrations */\nexport interface ClientMigrationContext {\n\t/** Documents that need migration */\n\tdirtyDocs: MigrationDoc[];\n\t/** Get Yjs document for a specific ID */\n\tgetYDoc(id: string): import(\"yjs\").Doc | null;\n\t/** Schema diff being applied */\n\tdiff: SchemaDiff;\n}\n\n/** Custom client migration function */\nexport type ClientMigrationFn = (\n\tdb: MigrationDatabase,\n\tctx: ClientMigrationContext,\n) => Promise<void>;\n\n/** Map of version numbers to custom client migrations */\nexport type ClientMigrationMap = Record<number, ClientMigrationFn>;\n\n// ─────────────────────────────────────────────────────────────────────────────\n// Versioned Collection Options\n// ─────────────────────────────────────────────────────────────────────────────\n\n/** Options for collection.create() with versioned schema */\nexport interface VersionedCollectionOptions<T extends object> {\n\t/** Versioned schema definition */\n\tschema: VersionedSchema<GenericValidator>;\n\t/** Persistence provider factory */\n\tpersistence: () => Promise<import(\"$/client/persistence/types\").Persistence>;\n\t/** Collection configuration */\n\tconfig: () => VersionedCollectionConfig<T>;\n\t/** Custom client migrations (override auto-generated) */\n\tclientMigrations?: ClientMigrationMap;\n\t/** Handler for migration errors */\n\tonMigrationError?: MigrationErrorHandler;\n}\n\n/** Configuration for versioned collection */\nexport interface VersionedCollectionConfig<T extends object> {\n\t/** Convex client instance */\n\tconvexClient: import(\"convex/browser\").ConvexClient;\n\t/** Collection API endpoints */\n\tapi: {\n\t\tmaterial: import(\"convex/server\").FunctionReference<\"query\">;\n\t\tdelta: import(\"convex/server\").FunctionReference<\"query\">;\n\t\treplicate: import(\"convex/server\").FunctionReference<\"mutation\">;\n\t\tpresence: import(\"convex/server\").FunctionReference<\"mutation\">;\n\t\tsession: import(\"convex/server\").FunctionReference<\"query\">;\n\t};\n\t/** Get document key */\n\tgetKey: (doc: T) => string | number;\n\t/** User identity provider */\n\tuser?: () => import(\"$/client/identity\").UserIdentity | undefined;\n}\n\n// ─────────────────────────────────────────────────────────────────────────────\n// Migration Runner\n// ─────────────────────────────────────────────────────────────────────────────\n\n/** Metadata stored in SQLite for schema versioning */\nexport interface SchemaMetadata {\n\tcollection: string;\n\tversion: number;\n\tmigratedAt: number;\n}\n\n/**\n * Get the current schema version from SQLite.\n */\nexport async function getStoredSchemaVersion(\n\tdb: MigrationDatabase,\n\tcollection: string,\n): Promise<number | null> {\n\ttry {\n\t\tconst result = await db.get<{ version: number }>(\n\t\t\t`SELECT version FROM __replicate_schema WHERE collection = ?`,\n\t\t\t[collection],\n\t\t);\n\t\treturn result?.version ?? null;\n\t} catch {\n\t\t// Table doesn't exist yet\n\t\treturn null;\n\t}\n}\n\n/**\n * Store the current schema version in SQLite.\n */\nexport async function setStoredSchemaVersion(\n\tdb: MigrationDatabase,\n\tcollection: string,\n\tversion: number,\n): Promise<void> {\n\tawait db.exec(`\n\t\tCREATE TABLE IF NOT EXISTS __replicate_schema (\n\t\t\tcollection TEXT PRIMARY KEY,\n\t\t\tversion INTEGER NOT NULL,\n\t\t\tmigratedAt INTEGER NOT NULL\n\t\t)\n\t`);\n\n\tawait db.run(\n\t\t`INSERT OR REPLACE INTO __replicate_schema (collection, version, migratedAt) VALUES (?, ?, ?)`,\n\t\t[collection, version, Date.now()],\n\t);\n}\n\n/**\n * Run auto-generated SQL migration.\n */\nexport async function runAutoMigration(\n\tdb: MigrationDatabase,\n\ttableName: string,\n\tdiff: SchemaDiff,\n): Promise<void> {\n\tfor (const sql of diff.generatedSQL) {\n\t\tconst resolvedSql = sql.replace(/%TABLE%/g, `\"${tableName}\"`);\n\t\tawait db.exec(resolvedSql);\n\t}\n}\n\n/**\n * Create a migration error.\n */\nexport function createMigrationError(\n\tcode: MigrationErrorCode,\n\tmessage: string,\n\tfromVersion: number,\n\ttoVersion: number,\n\toperation?: SchemaDiffOperation,\n): MigrationError {\n\treturn { code, message, fromVersion, toVersion, operation };\n}\n\n// ─────────────────────────────────────────────────────────────────────────────\n// Migration Execution\n// ─────────────────────────────────────────────────────────────────────────────\n\n/** Options for running migrations */\nexport interface RunMigrationsOptions<_T extends object = object> {\n\t/** Collection name */\n\tcollection: string;\n\t/** Versioned schema */\n\tschema: VersionedSchema<GenericValidator>;\n\t/** SQLite database interface */\n\tdb: MigrationDatabase;\n\t/** Custom client migrations (override auto-generated) */\n\tclientMigrations?: ClientMigrationMap;\n\t/** Handler for migration errors */\n\tonError?: MigrationErrorHandler;\n\t/** Get Yjs document for a specific ID (for custom migrations) */\n\tgetYDoc?: (id: string) => import(\"yjs\").Doc | null;\n\t/** List all document IDs in the collection */\n\tlistDocuments?: () => Promise<string[]>;\n}\n\n/** Result of running migrations */\nexport interface MigrationResult {\n\t/** Whether migration was needed and ran */\n\tmigrated: boolean;\n\t/** Previous schema version (null if first run) */\n\tfromVersion: number | null;\n\t/** Current schema version */\n\ttoVersion: number;\n\t/** Schema diff that was applied (null if no migration needed) */\n\tdiff: SchemaDiff | null;\n\t/** Error if migration failed */\n\terror?: MigrationError;\n}\n\n/**\n * Run migrations for a collection if needed.\n *\n * @example\n * ```typescript\n * const result = await runMigrations({\n *   collection: \"tasks\",\n *   schema: taskSchema,\n *   db: persistence.db!,\n * });\n *\n * if (result.migrated) {\n *   console.log(`Migrated from v${result.fromVersion} to v${result.toVersion}`);\n * }\n * ```\n */\nexport async function runMigrations(options: RunMigrationsOptions): Promise<MigrationResult> {\n\tconst { collection, schema, db, clientMigrations, onError, getYDoc, listDocuments } = options;\n\tconst targetVersion = schema.version;\n\n\t// Get stored schema version\n\tconst storedVersion = await getStoredSchemaVersion(db, collection);\n\n\t// First run - no migration needed, just store version\n\tif (storedVersion === null) {\n\t\tawait setStoredSchemaVersion(db, collection, targetVersion);\n\t\treturn {\n\t\t\tmigrated: false,\n\t\t\tfromVersion: null,\n\t\t\ttoVersion: targetVersion,\n\t\t\tdiff: null,\n\t\t};\n\t}\n\n\t// Already at target version\n\tif (storedVersion === targetVersion) {\n\t\treturn {\n\t\t\tmigrated: false,\n\t\t\tfromVersion: storedVersion,\n\t\t\ttoVersion: targetVersion,\n\t\t\tdiff: null,\n\t\t};\n\t}\n\n\t// Compute diff between stored and target versions\n\tlet diff: SchemaDiff;\n\ttry {\n\t\tdiff = schema.diff(storedVersion, targetVersion);\n\t} catch (err) {\n\t\tconst error = createMigrationError(\n\t\t\t\"SCHEMA_MISMATCH\",\n\t\t\t`Failed to compute schema diff: ${err instanceof Error ? err.message : String(err)}`,\n\t\t\tstoredVersion,\n\t\t\ttargetVersion,\n\t\t);\n\n\t\tif (onError) {\n\t\t\tconst recovery = await handleMigrationError(error, db, collection, onError);\n\t\t\tif (recovery.action === \"keep-old-schema\") {\n\t\t\t\treturn {\n\t\t\t\t\tmigrated: false,\n\t\t\t\t\tfromVersion: storedVersion,\n\t\t\t\t\ttoVersion: storedVersion,\n\t\t\t\t\tdiff: null,\n\t\t\t\t\terror,\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\tthrow err;\n\t}\n\n\t// Run migrations\n\ttry {\n\t\t// Check for custom client migration for target version\n\t\tconst customMigration = clientMigrations?.[targetVersion];\n\n\t\tif (customMigration) {\n\t\t\t// Run custom migration\n\t\t\tconst docIds = listDocuments ? await listDocuments() : [];\n\n\t\t\t// Build dirtyDocs list from document IDs\n\t\t\t// Note: field data must be populated by getYDoc if needed\n\t\t\tconst dirtyDocs: MigrationDoc[] = docIds.map(id => ({\n\t\t\t\tid,\n\t\t\t\tfields: new Map(),\n\t\t\t}));\n\n\t\t\tconst ctx: ClientMigrationContext = {\n\t\t\t\tdirtyDocs,\n\t\t\t\tgetYDoc: getYDoc ?? (() => null),\n\t\t\t\tdiff,\n\t\t\t};\n\n\t\t\tawait customMigration(db, ctx);\n\t\t} else {\n\t\t\t// Run auto-generated SQL migrations\n\t\t\t// Use collection name as table name for document storage\n\t\t\tawait runAutoMigration(db, collection, diff);\n\t\t}\n\n\t\t// Update stored version\n\t\tawait setStoredSchemaVersion(db, collection, targetVersion);\n\n\t\treturn {\n\t\t\tmigrated: true,\n\t\t\tfromVersion: storedVersion,\n\t\t\ttoVersion: targetVersion,\n\t\t\tdiff,\n\t\t};\n\t} catch (err) {\n\t\tconst error = createMigrationError(\n\t\t\t\"SQLITE_ERROR\",\n\t\t\t`Migration failed: ${err instanceof Error ? err.message : String(err)}`,\n\t\t\tstoredVersion,\n\t\t\ttargetVersion,\n\t\t);\n\n\t\tif (onError) {\n\t\t\tconst recovery = await handleMigrationError(error, db, collection, onError);\n\t\t\tif (recovery.action === \"keep-old-schema\") {\n\t\t\t\treturn {\n\t\t\t\t\tmigrated: false,\n\t\t\t\t\tfromVersion: storedVersion,\n\t\t\t\t\ttoVersion: storedVersion,\n\t\t\t\t\tdiff: null,\n\t\t\t\t\terror,\n\t\t\t\t};\n\t\t\t}\n\t\t\tif (recovery.action === \"reset\") {\n\t\t\t\t// Clear all data and set to target version\n\t\t\t\tawait clearCollectionData(db, collection);\n\t\t\t\tawait setStoredSchemaVersion(db, collection, targetVersion);\n\t\t\t\treturn {\n\t\t\t\t\tmigrated: true,\n\t\t\t\t\tfromVersion: storedVersion,\n\t\t\t\t\ttoVersion: targetVersion,\n\t\t\t\t\tdiff,\n\t\t\t\t\terror,\n\t\t\t\t};\n\t\t\t}\n\t\t\tif (recovery.action === \"custom\" && recovery.handler) {\n\t\t\t\tawait recovery.handler();\n\t\t\t\treturn {\n\t\t\t\t\tmigrated: true,\n\t\t\t\t\tfromVersion: storedVersion,\n\t\t\t\t\ttoVersion: targetVersion,\n\t\t\t\t\tdiff,\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\tthrow err;\n\t}\n}\n\n/**\n * Handle migration error by calling user's error handler.\n */\nasync function handleMigrationError(\n\terror: MigrationError,\n\tdb: MigrationDatabase,\n\tcollection: string,\n\tonError: MigrationErrorHandler,\n): Promise<RecoveryAction> {\n\t// Check for pending changes by looking at deltas table\n\tlet pendingChanges = 0;\n\ttry {\n\t\tconst result = await db.get<{ count: number }>(\n\t\t\t`SELECT COUNT(*) as count FROM deltas WHERE collection LIKE ?`,\n\t\t\t[`${collection}:%`],\n\t\t);\n\t\tpendingChanges = result?.count ?? 0;\n\t} catch {\n\t\t// Ignore - table might not exist\n\t}\n\n\t// Get last sync timestamp from kv\n\tlet lastSyncedAt: Date | null = null;\n\ttry {\n\t\tconst result = await db.get<{ value: string }>(`SELECT value FROM kv WHERE key = ?`, [\n\t\t\t`lastSync:${collection}`,\n\t\t]);\n\t\tif (result?.value) {\n\t\t\tconst timestamp = JSON.parse(result.value);\n\t\t\tlastSyncedAt = new Date(timestamp);\n\t\t}\n\t} catch {\n\t\t// Ignore\n\t}\n\n\tconst context: RecoveryContext = {\n\t\terror,\n\t\tcanResetSafely: pendingChanges === 0,\n\t\tpendingChanges,\n\t\tlastSyncedAt,\n\t};\n\n\treturn onError(error, context);\n}\n\n/**\n * Clear all data for a collection (used by reset recovery action).\n */\nasync function clearCollectionData(db: MigrationDatabase, collection: string): Promise<void> {\n\t// Clear snapshots\n\tawait db.run(`DELETE FROM snapshots WHERE collection LIKE ?`, [`${collection}:%`]);\n\n\t// Clear deltas\n\tawait db.run(`DELETE FROM deltas WHERE collection LIKE ?`, [`${collection}:%`]);\n\n\t// Clear related kv entries\n\tawait db.run(`DELETE FROM kv WHERE key LIKE ?`, [`cursor:${collection}%`]);\n}\n","import type { GenericValidator } from \"convex/values\";\n\ninterface ValidatorShape {\n\tkind: string;\n\tfields?: Record<string, ValidatorShape>;\n\tvalue?: unknown;\n\tisOptional?: \"required\" | \"optional\";\n}\n\nfunction isProseValidator(validator: GenericValidator): boolean {\n\tconst v = validator as unknown as ValidatorShape;\n\n\tif (v.kind !== \"object\" || !v.fields) return false;\n\n\tconst { type, content } = v.fields;\n\n\tif (!type || type.kind !== \"literal\" || type.value !== \"doc\") {\n\t\treturn false;\n\t}\n\n\tif (!content) return false;\n\n\tconst contentValidator = content.isOptional === \"optional\" ? content : content;\n\treturn contentValidator.kind === \"array\" || (content.kind === \"object\" && !!content.fields);\n}\n\nexport function findProseFields(validator: GenericValidator): string[] {\n\tconst v = validator as unknown as ValidatorShape;\n\n\tif (v.kind !== \"object\" || !v.fields) return [];\n\n\tconst proseFields: string[] = [];\n\n\tfor (const [fieldName, fieldValidator] of Object.entries(v.fields)) {\n\t\tif (isProseValidator(fieldValidator as unknown as GenericValidator)) {\n\t\t\tproseFields.push(fieldName);\n\t\t}\n\t}\n\n\treturn proseFields;\n}\n\nexport function emptyProse(): { type: \"doc\"; content: never[] } {\n\treturn { type: \"doc\", content: [] };\n}\n","export class NetworkError extends Error {\n\treadonly _tag = \"NetworkError\" as const;\n\treadonly retryable = true as const;\n\treadonly cause: unknown;\n\treadonly operation: string;\n\n\tconstructor(props: { operation: string; cause: unknown }) {\n\t\tsuper(`Network error during ${props.operation}`);\n\t\tthis.name = \"NetworkError\";\n\t\tthis.operation = props.operation;\n\t\tthis.cause = props.cause;\n\t}\n}\n\nexport class IDBError extends Error {\n\treadonly _tag = \"IDBError\" as const;\n\treadonly operation: \"get\" | \"set\" | \"delete\" | \"clear\";\n\treadonly cause: unknown;\n\treadonly store?: string;\n\treadonly key?: string;\n\n\tconstructor(props: {\n\t\toperation: \"get\" | \"set\" | \"delete\" | \"clear\";\n\t\tcause: unknown;\n\t\tstore?: string;\n\t\tkey?: string;\n\t}) {\n\t\tsuper(`IDB ${props.operation} error${props.key ? ` for key ${props.key}` : \"\"}`);\n\t\tthis.name = \"IDBError\";\n\t\tthis.operation = props.operation;\n\t\tthis.cause = props.cause;\n\t\tthis.store = props.store;\n\t\tthis.key = props.key;\n\t}\n}\n\nexport class IDBWriteError extends Error {\n\treadonly _tag = \"IDBWriteError\" as const;\n\treadonly key: string;\n\treadonly value: unknown;\n\treadonly cause: unknown;\n\n\tconstructor(props: { key: string; value: unknown; cause: unknown }) {\n\t\tsuper(`IDB write error for key ${props.key}`);\n\t\tthis.name = \"IDBWriteError\";\n\t\tthis.key = props.key;\n\t\tthis.value = props.value;\n\t\tthis.cause = props.cause;\n\t}\n}\n\nexport class ReconciliationError extends Error {\n\treadonly _tag = \"ReconciliationError\" as const;\n\treadonly collection: string;\n\treadonly reason: string;\n\toverride readonly cause?: unknown;\n\n\tconstructor(props: { collection: string; reason: string; cause?: unknown }) {\n\t\tsuper(`Reconciliation error in ${props.collection}: ${props.reason}`);\n\t\tthis.name = \"ReconciliationError\";\n\t\tthis.collection = props.collection;\n\t\tthis.reason = props.reason;\n\t\tthis.cause = props.cause;\n\t}\n}\n\nexport class ProseError extends Error {\n\treadonly _tag = \"ProseError\" as const;\n\treadonly document: string;\n\treadonly field: string;\n\treadonly collection: string;\n\n\tconstructor(props: { document: string; field: string; collection: string }) {\n\t\tsuper(`Prose error for ${props.collection}/${props.document}/${props.field}`);\n\t\tthis.name = \"ProseError\";\n\t\tthis.document = props.document;\n\t\tthis.field = props.field;\n\t\tthis.collection = props.collection;\n\t}\n}\n\nexport class CollectionNotReadyError extends Error {\n\treadonly _tag = \"CollectionNotReadyError\" as const;\n\treadonly collection: string;\n\treadonly reason: string;\n\n\tconstructor(props: { collection: string; reason: string }) {\n\t\tsuper(`Collection ${props.collection} not ready: ${props.reason}`);\n\t\tthis.name = \"CollectionNotReadyError\";\n\t\tthis.collection = props.collection;\n\t\tthis.reason = props.reason;\n\t}\n}\n\n/** Error that should not be retried (auth failures, validation errors) */\nexport class NonRetriableError extends Error {\n\tconstructor(message: string) {\n\t\tsuper(message);\n\t\tthis.name = \"NonRetriableError\";\n\t}\n}\n","import type { KeyValueStore } from \"$/client/persistence/types\";\n\nexport type Seq = number;\n\nexport interface SeqService {\n\tload(collection: string): Promise<Seq>;\n\tsave(collection: string, seq: Seq): Promise<void>;\n\tclear(collection: string): Promise<void>;\n}\n\nexport function createSeqService(kv: KeyValueStore): SeqService {\n\treturn {\n\t\tasync load(collection: string): Promise<Seq> {\n\t\t\tconst key = `cursor:${collection}`;\n\t\t\tconst stored = await kv.get<Seq>(key);\n\t\t\treturn stored ?? 0;\n\t\t},\n\n\t\tasync save(collection: string, seq: Seq): Promise<void> {\n\t\t\tconst key = `cursor:${collection}`;\n\t\t\tawait kv.set(key, seq);\n\t\t},\n\n\t\tasync clear(collection: string): Promise<void> {\n\t\t\tconst key = `cursor:${collection}`;\n\t\t\tawait kv.del(key);\n\t\t},\n\t};\n}\n","import type { KeyValueStore } from \"$/client/persistence/types\";\n\nconst SESSION_CLIENT_ID_KEY = \"replicate:sessionClientId\";\n\nlet cachedSessionClientId: string | null = null;\n\nfunction generateSessionClientId(): string {\n\tif (typeof crypto !== \"undefined\" && crypto.randomUUID) {\n\t\treturn crypto.randomUUID();\n\t}\n\treturn String(Math.floor(Math.random() * Number.MAX_SAFE_INTEGER));\n}\n\nexport async function getClientId(kv: KeyValueStore): Promise<string> {\n\tif (cachedSessionClientId) {\n\t\treturn cachedSessionClientId;\n\t}\n\n\tconst stored = await kv.get<string>(SESSION_CLIENT_ID_KEY);\n\tif (stored) {\n\t\tcachedSessionClientId = stored;\n\t\treturn stored;\n\t}\n\n\tconst newId = generateSessionClientId();\n\tcachedSessionClientId = newId;\n\tawait kv.set(SESSION_CLIENT_ID_KEY, newId);\n\n\treturn newId;\n}\n","/**\n * Replicate Helpers - Collection-bound functions for TanStack DB optimistic updates\n *\n * Each collection gets its own set of bound functions that operate on that\n * collection's TanStack DB instance. No global state - fully concurrent-safe.\n */\n\nexport interface ReplicateParams {\n\treadonly begin: () => void;\n\treadonly write: (message: { type: \"insert\" | \"update\" | \"delete\"; value: unknown }) => void;\n\treadonly commit: () => void;\n\treadonly truncate: () => void;\n}\n\n/**\n * Bound replicate operations for a specific collection.\n * These functions are already tied to the collection's TanStack DB params.\n */\nexport interface BoundReplicateOps<T> {\n\treadonly insert: (items: T[]) => void;\n\treadonly delete: (items: T[]) => void;\n\treadonly upsert: (items: T[]) => void;\n\treadonly replace: (items: T[]) => void;\n}\n\n/**\n * Create bound replicate operations for a collection.\n * Returns functions that are already tied to the collection's params.\n * This is the proper way to handle multiple concurrent collections.\n *\n * @example\n * ```typescript\n * const ops = createReplicateOps<Task>(params);\n * ops.replace(items);  // Always targets THIS collection's TanStack DB\n * ops.upsert([item]);\n * ops.delete([item]);\n * ```\n */\nexport function createReplicateOps<T>(params: ReplicateParams): BoundReplicateOps<T> {\n\treturn {\n\t\tinsert(items: T[]): void {\n\t\t\tparams.begin();\n\t\t\tfor (const item of items) {\n\t\t\t\tparams.write({ type: \"insert\", value: item });\n\t\t\t}\n\t\t\tparams.commit();\n\t\t},\n\n\t\tdelete(items: T[]): void {\n\t\t\tparams.begin();\n\t\t\tfor (const item of items) {\n\t\t\t\tparams.write({ type: \"delete\", value: item });\n\t\t\t}\n\t\t\tparams.commit();\n\t\t},\n\n\t\tupsert(items: T[]): void {\n\t\t\tparams.begin();\n\t\t\tfor (const item of items) {\n\t\t\t\tparams.write({ type: \"update\", value: item });\n\t\t\t}\n\t\t\tparams.commit();\n\t\t},\n\n\t\treplace(items: T[]): void {\n\t\t\tparams.begin();\n\t\t\tparams.truncate();\n\t\t\tfor (const item of items) {\n\t\t\t\tparams.write({ type: \"insert\", value: item });\n\t\t\t}\n\t\t\tparams.commit();\n\t\t},\n\t};\n}\n\n// Internal - for test cleanup only\nexport function _resetReplicateParams(): void {\n\t// No-op now - nothing to reset since we don't use global state\n}\n","/**\n * Merge Helpers - Plain functions for Yjs CRDT operations\n *\n * Provides state encoding and merge operations.\n */\n\nimport * as Y from \"yjs\";\n\n/**\n * Apply a binary update to a Yjs document.\n * Y.applyUpdateV2 is already atomic, no need for transaction wrapper.\n */\nexport function applyUpdate(doc: Y.Doc, update: Uint8Array, origin?: string): void {\n\tY.applyUpdateV2(doc, update, origin);\n}\n\n/**\n * Get a Y.Map from a Yjs document by name.\n */\nexport function getYMap<T = unknown>(doc: Y.Doc, name: string): Y.Map<T> {\n\treturn doc.getMap(name);\n}\n\n/**\n * Execute a function within a Yjs transaction.\n */\nexport function yjsTransact<A>(doc: Y.Doc, fn: () => A, origin?: string): A {\n\treturn doc.transact(fn, origin);\n}\n\n/**\n * Execute a function within a Yjs transaction and capture the delta.\n * Returns both the function result and a delta containing only the changes made.\n */\nexport function transactWithDelta<A>(\n\tdoc: Y.Doc,\n\tfn: () => A,\n\torigin?: string,\n): { result: A; delta: Uint8Array } {\n\tconst beforeVector = Y.encodeStateVector(doc);\n\tconst result = doc.transact(fn, origin);\n\tconst delta = Y.encodeStateAsUpdateV2(doc, beforeVector);\n\treturn { result, delta };\n}\n\n// ============================================================================\n// Yjs Serialization System\n// ============================================================================\n// Yjs uses `instanceof AbstractType` internally in toJSON() which breaks when\n// multiple Yjs module instances exist (common with bundlers). We detect Yjs\n// types by their internal structure (`doc`, `_map`, `_start` properties) which\n// is stable across instances, then manually iterate using forEach/toArray.\n// ============================================================================\n\n/**\n * Check if a value is a Yjs AbstractType by checking internal properties.\n * All Yjs types (Y.Map, Y.Array, Y.Text, Y.XmlFragment, etc.) extend AbstractType\n * and have these properties regardless of which module instance created them.\n */\nfunction isYjsAbstractType(value: unknown): boolean {\n\tif (value === null || typeof value !== \"object\") return false;\n\tconst v = value as Record<string, unknown>;\n\t// AbstractType has: doc (Doc|null), _map (Map), _eH (event handler)\n\treturn \"_map\" in v && \"_eH\" in v && \"doc\" in v;\n}\n\n/**\n * Check if a value is a Y.Map.\n * Y.Map has keys() method which Y.XmlFragment does not.\n */\nfunction isYMap(value: unknown): boolean {\n\tif (!isYjsAbstractType(value)) return false;\n\tconst v = value as Record<string, unknown>;\n\treturn typeof v.keys === \"function\" && typeof v.get === \"function\";\n}\n\n/**\n * Check if a value is a Y.Array (has toArray but not get - distinguishes from Y.Map).\n */\nfunction isYArray(value: unknown): boolean {\n\tif (!isYjsAbstractType(value)) return false;\n\tconst v = value as Record<string, unknown>;\n\treturn typeof v.toArray === \"function\" && typeof v.get !== \"function\";\n}\n\n/**\n * Check if a value is a Y.XmlFragment or Y.XmlElement.\n * XmlFragment has toArray() and get(index), but NOT keys() like Y.Map.\n */\nfunction isYXmlFragment(value: unknown): value is Y.XmlFragment {\n\tif (!isYjsAbstractType(value)) return false;\n\tconst v = value as Record<string, unknown>;\n\t// XmlFragment has toArray() but NOT keys() - keys() is unique to Y.Map\n\treturn typeof v.toArray === \"function\" && typeof v.keys !== \"function\";\n}\n\n/**\n * Recursively serialize a Yjs value to plain JavaScript.\n * Handles Y.Map, Y.Array, Y.XmlFragment without using instanceof.\n */\nfunction serialize(value: unknown): unknown {\n\t// Primitives pass through\n\tif (value === null || value === undefined) return value;\n\tif (typeof value !== \"object\") return value;\n\n\t// Check for XmlFragment first (converts to ProseMirror JSON)\n\tif (isYXmlFragment(value)) {\n\t\treturn fragmentToJSON(value);\n\t}\n\n\t// Y.Map - iterate with forEach and recursively serialize values\n\tif (isYMap(value)) {\n\t\tconst result: Record<string, unknown> = {};\n\t\tconst ymap = value as Y.Map<unknown>;\n\t\tymap.forEach((v, k) => {\n\t\t\tresult[k] = serialize(v);\n\t\t});\n\t\treturn result;\n\t}\n\n\t// Y.Array - convert to array and recursively serialize elements\n\tif (isYArray(value)) {\n\t\treturn (value as Y.Array<unknown>).toArray().map(serialize);\n\t}\n\n\t// Regular object/array (not a Yjs type) - return as-is\n\treturn value;\n}\n\n/**\n * Serialize a Y.Map to a plain object.\n */\nexport function serializeYMap(ymap: Y.Map<unknown>): Record<string, unknown> {\n\treturn serialize(ymap) as Record<string, unknown>;\n}\n\n/**\n * Extract all items from a Y.Map as plain objects.\n */\nexport function extractItems<T>(ymap: Y.Map<unknown>): T[] {\n\tconst items: T[] = [];\n\tymap.forEach(value => {\n\t\tif (isYMap(value)) {\n\t\t\titems.push(serialize(value) as T);\n\t\t}\n\t});\n\treturn items;\n}\n\n/**\n * Extract a single item from a Y.Map by key.\n */\nexport function extractItem<T>(ymap: Y.Map<unknown>, key: string): T | null {\n\tconst value = ymap.get(key);\n\tif (isYMap(value)) {\n\t\treturn serialize(value) as T;\n\t}\n\treturn null;\n}\n\nimport type { XmlFragmentJSON, XmlNodeJSON } from \"$/shared\";\n\n/**\n * Check if a value looks like ProseMirror/BlockNote JSON document.\n * Used internally to auto-detect prose fields during insert/update.\n */\nexport function isDoc(value: unknown): value is XmlFragmentJSON {\n\treturn (\n\t\ttypeof value === \"object\" &&\n\t\tvalue !== null &&\n\t\t\"type\" in value &&\n\t\t(value as { type: unknown }).type === \"doc\"\n\t);\n}\n\n/**\n * Convert a Y.XmlFragment to ProseMirror-compatible JSON.\n */\nexport function fragmentToJSON(fragment: Y.XmlFragment): XmlFragmentJSON {\n\tconst content: XmlNodeJSON[] = [];\n\n\tfor (const child of fragment.toArray()) {\n\t\tif (child instanceof Y.XmlElement) {\n\t\t\tcontent.push(xmlElementToJSON(child));\n\t\t} else if (child instanceof Y.XmlText) {\n\t\t\tconst textContent = xmlTextToJSON(child);\n\t\t\tif (textContent.length > 0) {\n\t\t\t\tcontent.push({\n\t\t\t\t\ttype: \"paragraph\",\n\t\t\t\t\tcontent: textContent,\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n\n\treturn {\n\t\ttype: \"doc\",\n\t\tcontent: content.length > 0 ? content : [{ type: \"paragraph\" }],\n\t};\n}\n\nfunction xmlElementToJSON(element: Y.XmlElement): XmlNodeJSON {\n\tconst result: XmlNodeJSON = {\n\t\ttype: element.nodeName,\n\t};\n\n\tconst attrs = element.getAttributes();\n\tif (Object.keys(attrs).length > 0) {\n\t\tresult.attrs = attrs;\n\t}\n\n\tconst content: XmlNodeJSON[] = [];\n\tfor (const child of element.toArray()) {\n\t\tif (child instanceof Y.XmlElement) {\n\t\t\tcontent.push(xmlElementToJSON(child));\n\t\t} else if (child instanceof Y.XmlText) {\n\t\t\tcontent.push(...xmlTextToJSON(child));\n\t\t}\n\t}\n\n\tif (content.length > 0) {\n\t\tresult.content = content;\n\t}\n\n\treturn result;\n}\n\nfunction xmlTextToJSON(text: Y.XmlText): XmlNodeJSON[] {\n\tconst result: XmlNodeJSON[] = [];\n\tconst delta = text.toDelta();\n\n\tfor (const op of delta) {\n\t\tif (typeof op.insert === \"string\") {\n\t\t\tconst node: XmlNodeJSON = {\n\t\t\t\ttype: \"text\",\n\t\t\t\ttext: op.insert,\n\t\t\t};\n\n\t\t\tif (op.attributes && Object.keys(op.attributes).length > 0) {\n\t\t\t\tnode.marks = Object.entries(op.attributes).map(([type, attrs]) => ({\n\t\t\t\t\ttype,\n\t\t\t\t\tattrs: typeof attrs === \"object\" ? (attrs as Record<string, unknown>) : undefined,\n\t\t\t\t}));\n\t\t\t}\n\n\t\t\tresult.push(node);\n\t\t}\n\t}\n\n\treturn result;\n}\n\n/**\n * Initialize a Y.XmlFragment from ProseMirror-compatible JSON.\n */\nexport function fragmentFromJSON(fragment: Y.XmlFragment, json: XmlFragmentJSON): void {\n\tif (!json.content) return;\n\n\tfor (const node of json.content) {\n\t\tappendNodeToFragment(fragment, node);\n\t}\n}\n\n/**\n * Extract plain text from ProseMirror/BlockNote JSON content.\n * Handles various content structures defensively for search and display.\n */\nexport function extract(content: unknown): string {\n\tif (!content || typeof content !== \"object\") return \"\";\n\n\tconst doc = content as { content?: unknown; type?: string };\n\n\t// Handle XmlFragmentJSON format - content must be an array\n\tif (!doc.content || !Array.isArray(doc.content)) return \"\";\n\n\treturn doc.content\n\t\t.map((block: { content?: unknown }) => {\n\t\t\tif (!block.content || !Array.isArray(block.content)) return \"\";\n\t\t\treturn block.content.map((node: { text?: string }) => node.text || \"\").join(\"\");\n\t\t})\n\t\t.join(\" \");\n}\n\nfunction appendNodeToFragment(parent: Y.XmlFragment | Y.XmlElement, node: XmlNodeJSON): void {\n\tif (node.type === \"text\") {\n\t\tconst text = new Y.XmlText();\n\t\tif (node.text) {\n\t\t\tconst attrs: Record<string, unknown> = {};\n\t\t\tif (node.marks) {\n\t\t\t\tfor (const mark of node.marks) {\n\t\t\t\t\tattrs[mark.type] = mark.attrs ?? true;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttext.insert(0, node.text, Object.keys(attrs).length > 0 ? attrs : undefined);\n\t\t}\n\t\tparent.insert(parent.length, [text]);\n\t} else {\n\t\tconst element = new Y.XmlElement(node.type);\n\n\t\tif (node.attrs) {\n\t\t\tfor (const [key, value] of Object.entries(node.attrs)) {\n\t\t\t\telement.setAttribute(key, value as string);\n\t\t\t}\n\t\t}\n\n\t\tif (node.content) {\n\t\t\tfor (const child of node.content) {\n\t\t\t\tappendNodeToFragment(element, child);\n\t\t\t}\n\t\t}\n\n\t\tparent.insert(parent.length, [element]);\n\t}\n}\n\n/**\n * Serialize any value, handling Yjs types specially.\n * Uses our custom serialization system that works across module instances.\n */\nexport function serializeYMapValue(value: unknown): unknown {\n\treturn serialize(value);\n}\n\n/**\n * Get a Y.XmlFragment from a document's field.\n * Returns null if the document or field doesn't exist, or if the field is not an XmlFragment.\n */\nexport function getFragmentFromYMap(\n\tymap: Y.Map<unknown>,\n\tdocument: string,\n\tfield: string,\n): Y.XmlFragment | null {\n\tconst doc = ymap.get(document);\n\tif (!isYMap(doc)) {\n\t\treturn null;\n\t}\n\n\tconst fieldValue = (doc as Y.Map<unknown>).get(field);\n\tif (isYXmlFragment(fieldValue)) {\n\t\treturn fieldValue;\n\t}\n\n\treturn null;\n}\n","import * as Y from \"yjs\";\nimport type { PersistenceProvider } from \"$/client/persistence/types\";\nimport { fragmentToJSON } from \"$/client/merge\";\n\nexport type DocPersistenceFactory = (document: string, ydoc: Y.Doc) => PersistenceProvider;\n\nexport interface DocumentManager {\n\treadonly collection: string;\n\n\tget(id: string): Y.Doc | undefined;\n\tgetOrCreate(id: string): Y.Doc;\n\thas(id: string): boolean;\n\tdelete(id: string): void;\n\n\tgetFields(id: string): Y.Map<unknown> | null;\n\tgetFragment(id: string, field: string): Y.XmlFragment | null;\n\n\tapplyUpdate(id: string, update: Uint8Array, origin?: string): void;\n\tencodeState(id: string): Uint8Array;\n\tencodeStateVector(id: string): Uint8Array;\n\ttransactWithDelta(id: string, fn: (fields: Y.Map<unknown>) => void, origin?: string): Uint8Array;\n\n\tdocuments(): string[];\n\tenablePersistence(factory: DocPersistenceFactory): Promise<void>[];\n\tdestroy(): void;\n}\n\nexport function createDocumentManager(collection: string): DocumentManager {\n\tconst docs = new Map<string, Y.Doc>();\n\tconst persistence = new Map<string, PersistenceProvider>();\n\tlet persistenceFactory: DocPersistenceFactory | null = null;\n\n\tconst makeGuid = (id: string): string => `${collection}:${id}`;\n\n\tconst manager: DocumentManager = {\n\t\tcollection,\n\n\t\tget(id: string): Y.Doc | undefined {\n\t\t\treturn docs.get(id);\n\t\t},\n\n\t\tgetOrCreate(id: string): Y.Doc {\n\t\t\tlet doc = docs.get(id);\n\t\t\tif (!doc) {\n\t\t\t\tdoc = new Y.Doc({ guid: makeGuid(id) });\n\t\t\t\tdocs.set(id, doc);\n\n\t\t\t\tif (persistenceFactory && !persistence.has(id)) {\n\t\t\t\t\tconst provider = persistenceFactory(id, doc);\n\t\t\t\t\tpersistence.set(id, provider);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn doc;\n\t\t},\n\n\t\thas(id: string): boolean {\n\t\t\treturn docs.has(id);\n\t\t},\n\n\t\tdelete(id: string): void {\n\t\t\tconst doc = docs.get(id);\n\t\t\tif (doc) {\n\t\t\t\tdoc.destroy();\n\t\t\t\tdocs.delete(id);\n\t\t\t}\n\n\t\t\tconst provider = persistence.get(id);\n\t\t\tif (provider) {\n\t\t\t\tprovider.destroy();\n\t\t\t\tpersistence.delete(id);\n\t\t\t}\n\t\t},\n\n\t\tgetFields(id: string): Y.Map<unknown> | null {\n\t\t\tconst doc = docs.get(id);\n\t\t\treturn doc ? doc.getMap(\"fields\") : null;\n\t\t},\n\n\t\tgetFragment(id: string, field: string): Y.XmlFragment | null {\n\t\t\tconst fields = this.getFields(id);\n\t\t\tif (!fields) return null;\n\n\t\t\tconst value = fields.get(field);\n\t\t\tif (value instanceof Y.XmlFragment) {\n\t\t\t\treturn value;\n\t\t\t}\n\n\t\t\treturn null;\n\t\t},\n\n\t\tapplyUpdate(id: string, update: Uint8Array, origin?: string): void {\n\t\t\tconst doc = this.getOrCreate(id);\n\t\t\tY.applyUpdateV2(doc, update, origin);\n\t\t},\n\n\t\tencodeState(id: string): Uint8Array {\n\t\t\tconst doc = docs.get(id);\n\t\t\treturn doc ? Y.encodeStateAsUpdateV2(doc) : new Uint8Array();\n\t\t},\n\n\t\tencodeStateVector(id: string): Uint8Array {\n\t\t\tconst doc = docs.get(id);\n\t\t\tif (!doc) {\n\t\t\t\tconst emptyDoc = new Y.Doc();\n\t\t\t\tconst vector = Y.encodeStateVector(emptyDoc);\n\t\t\t\temptyDoc.destroy();\n\t\t\t\treturn vector;\n\t\t\t}\n\t\t\treturn Y.encodeStateVector(doc);\n\t\t},\n\n\t\ttransactWithDelta(\n\t\t\tid: string,\n\t\t\tfn: (fields: Y.Map<unknown>) => void,\n\t\t\torigin?: string,\n\t\t): Uint8Array {\n\t\t\tconst doc = this.getOrCreate(id);\n\t\t\tconst fields = doc.getMap<unknown>(\"fields\");\n\t\t\tconst beforeVector = Y.encodeStateVector(doc);\n\n\t\t\tdoc.transact(() => fn(fields), origin);\n\n\t\t\treturn Y.encodeStateAsUpdateV2(doc, beforeVector);\n\t\t},\n\n\t\tdocuments(): string[] {\n\t\t\treturn Array.from(docs.keys());\n\t\t},\n\n\t\tenablePersistence(factory: DocPersistenceFactory): Promise<void>[] {\n\t\t\tconst promises: Promise<void>[] = [];\n\n\t\t\tfor (const [id, doc] of docs.entries()) {\n\t\t\t\tif (!persistence.has(id)) {\n\t\t\t\t\tconst provider = factory(id, doc);\n\t\t\t\t\tpersistence.set(id, provider);\n\t\t\t\t\tpromises.push(provider.whenSynced);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpersistenceFactory = factory;\n\t\t\treturn promises;\n\t\t},\n\n\t\tdestroy(): void {\n\t\t\tfor (const provider of persistence.values()) {\n\t\t\t\tprovider.destroy();\n\t\t\t}\n\t\t\tpersistence.clear();\n\n\t\t\tfor (const doc of docs.values()) {\n\t\t\t\tdoc.destroy();\n\t\t\t}\n\t\t\tdocs.clear();\n\t\t},\n\t};\n\n\treturn manager;\n}\n\nexport function serializeDocument(\n\tmanager: DocumentManager,\n\tid: string,\n): Record<string, unknown> | null {\n\tconst fields = manager.getFields(id);\n\tif (!fields) return null;\n\n\tconst result: Record<string, unknown> = { id };\n\n\tfields.forEach((value, key) => {\n\t\tif (value instanceof Y.XmlFragment) {\n\t\t\tresult[key] = fragmentToJSON(value);\n\t\t} else if (value instanceof Y.Map) {\n\t\t\tresult[key] = value.toJSON();\n\t\t} else if (value instanceof Y.Array) {\n\t\t\tresult[key] = value.toJSON();\n\t\t} else {\n\t\t\tresult[key] = value;\n\t\t}\n\t});\n\n\treturn result;\n}\n\nexport function isDocumentDeleted(manager: DocumentManager, id: string): boolean {\n\tconst doc = manager.get(id);\n\tif (!doc) return false;\n\tconst meta = doc.getMap(\"_meta\");\n\treturn meta.get(\"_deleted\") === true;\n}\n\nexport function extractAllDocuments(manager: DocumentManager): Record<string, unknown>[] {\n\tconst documents: Record<string, unknown>[] = [];\n\n\tfor (const id of manager.documents()) {\n\t\tif (isDocumentDeleted(manager, id)) continue;\n\t\tconst doc = serializeDocument(manager, id);\n\t\tif (doc) {\n\t\t\tdocuments.push(doc);\n\t\t}\n\t}\n\n\treturn documents;\n}\n","import * as Y from \"yjs\";\n\nexport function createDeleteDelta(): Uint8Array {\n\tconst doc = new Y.Doc();\n\tconst meta = doc.getMap(\"_meta\");\n\n\tdoc.transact(() => {\n\t\tmeta.set(\"_deleted\", true);\n\t\tmeta.set(\"_deletedAt\", Date.now());\n\t});\n\n\tconst update = Y.encodeStateAsUpdateV2(doc);\n\tdoc.destroy();\n\treturn update;\n}\n\n/**\n * Apply delete marker to an EXISTING Y.Doc.\n * This triggers the persistence provider's update handler,\n * ensuring the delete is saved to local storage.\n */\nexport function applyDeleteMarkerToDoc(ydoc: Y.Doc): Uint8Array {\n\tconst meta = ydoc.getMap(\"_meta\");\n\tconst beforeVector = Y.encodeStateVector(ydoc);\n\n\tydoc.transact(() => {\n\t\tmeta.set(\"_deleted\", true);\n\t\tmeta.set(\"_deletedAt\", Date.now());\n\t});\n\n\treturn Y.encodeStateAsUpdateV2(ydoc, beforeVector);\n}\n\nexport function createUpdateDelta(\n\tydoc: Y.Doc,\n\tchanges: Record<string, unknown>,\n\tproseFields: Set<string>,\n): Uint8Array {\n\tconst fields = ydoc.getMap(\"fields\");\n\tconst beforeVector = Y.encodeStateVector(ydoc);\n\n\tydoc.transact(() => {\n\t\tfor (const [key, value] of Object.entries(changes)) {\n\t\t\tif (key === \"id\") continue;\n\t\t\tif (proseFields.has(key)) continue;\n\n\t\t\tfields.set(key, value);\n\t\t}\n\t});\n\n\treturn Y.encodeStateAsUpdateV2(ydoc, beforeVector);\n}\n","import { getLogger as getLogTapeLogger, type Logger } from \"@logtape/logtape\";\n\nconst PROJECT_NAME = \"replicate\";\n\nexport function getLogger(category: string[]): Logger {\n\treturn getLogTapeLogger([PROJECT_NAME, ...category]);\n}\n\nexport type { Logger };\n","import type { ConvexClient } from \"convex/browser\";\nimport type { FunctionReference } from \"convex/server\";\nimport type { Collection } from \"@tanstack/db\";\nimport type { Persistence } from \"$/client/persistence/types\";\nimport type { DocumentManager } from \"$/client/documents\";\nimport type { AnonymousPresenceConfig, UserIdentity } from \"$/client/identity\";\n\ninterface ConvexCollectionApi {\n\tmaterial: FunctionReference<\"query\">;\n\tdelta: FunctionReference<\"query\">;\n\treplicate: FunctionReference<\"mutation\">;\n\tpresence: FunctionReference<\"mutation\">;\n\tsession: FunctionReference<\"query\">;\n}\n\nexport interface CollectionContext {\n\tcollection: string;\n\tdocManager: DocumentManager;\n\tclient: ConvexClient;\n\tapi: ConvexCollectionApi;\n\tpersistence: Persistence;\n\tfields: Set<string>;\n\tfragmentObservers: Map<string, () => void>;\n\tcleanup?: () => void;\n\tclientId?: string;\n\tref?: Collection<any>;\n\tsynced?: Promise<void>;\n\tresolve?: () => void;\n\tactorReady?: Promise<void>;\n\tresolveActorReady?: () => void;\n\tuserGetter?: () => UserIdentity | undefined;\n\tanonymousPresence?: AnonymousPresenceConfig;\n}\n\nconst contexts = new Map<string, CollectionContext>();\n\nexport function getContext(collection: string): CollectionContext {\n\tconst ctx = contexts.get(collection);\n\tif (!ctx) throw new Error(`Collection ${collection} not initialized`);\n\treturn ctx;\n}\n\nexport function hasContext(collection: string): boolean {\n\treturn contexts.has(collection);\n}\n\ntype InitContextConfig = Omit<\n\tCollectionContext,\n\t\"fragmentObservers\" | \"cleanup\" | \"clientId\" | \"ref\"\n>;\n\nexport function initContext(config: InitContextConfig): CollectionContext {\n\tlet resolver: () => void;\n\tconst synced = new Promise<void>(r => {\n\t\tresolver = r;\n\t});\n\n\tlet actorResolver: () => void;\n\tconst actorReady = new Promise<void>(r => {\n\t\tactorResolver = r;\n\t});\n\n\tconst ctx: CollectionContext = {\n\t\t...config,\n\t\tfragmentObservers: new Map(),\n\t\tsynced,\n\t\tresolve: resolver!,\n\t\tactorReady,\n\t\tresolveActorReady: actorResolver!,\n\t};\n\tcontexts.set(config.collection, ctx);\n\treturn ctx;\n}\n\nexport function deleteContext(collection: string): void {\n\tconst ctx = contexts.get(collection);\n\tif (ctx) {\n\t\t// Clean up fragment observers before deleting context\n\t\tfor (const [, cleanupFn] of ctx.fragmentObservers) {\n\t\t\ttry {\n\t\t\t\tcleanupFn();\n\t\t\t} catch {\n\t\t\t\t// Ignore cleanup errors during context deletion\n\t\t\t}\n\t\t}\n\t\tctx.fragmentObservers.clear();\n\n\t\t// Call the cleanup function if present\n\t\tif (ctx.cleanup) {\n\t\t\ttry {\n\t\t\t\tctx.cleanup();\n\t\t\t} catch {\n\t\t\t\t// Ignore cleanup errors during context deletion\n\t\t\t}\n\t\t}\n\t}\n\tcontexts.delete(collection);\n}\n\ntype UpdateableFields = \"clientId\" | \"ref\" | \"cleanup\";\n\nexport function updateContext(\n\tcollection: string,\n\tupdates: Partial<Pick<CollectionContext, UpdateableFields>>,\n): CollectionContext {\n\tconst ctx = getContext(collection);\n\tObject.assign(ctx, updates);\n\treturn ctx;\n}\n","import * as Y from \"yjs\";\nimport { getLogger } from \"$/shared/logger\";\n\nconst logger = getLogger([\"replicate\", \"sync\"]);\n\nexport interface DocumentSync {\n\tonLocalChange(): void;\n\tonServerUpdate(): void;\n\tisPending(): boolean;\n\tonPendingChange(callback: (pending: boolean) => void): () => void;\n\tdestroy(): void;\n}\n\nconst MAX_RETRIES = 3;\nconst RETRY_DELAY_MS = 1000;\n\nexport function createDocumentSync(\n\tdocumentId: string,\n\tydoc: Y.Doc,\n\tsyncFn: () => Promise<void>,\n\tdebounceMs = 50,\n): DocumentSync {\n\tlet timeoutId: ReturnType<typeof setTimeout> | null = null;\n\tlet retryTimeoutId: ReturnType<typeof setTimeout> | null = null;\n\tlet pending = false;\n\tlet destroyed = false;\n\tlet retryCount = 0;\n\tconst pendingListeners = new Set<(pending: boolean) => void>();\n\n\tconst setPending = (value: boolean) => {\n\t\tif (pending !== value) {\n\t\t\tpending = value;\n\t\t\tpendingListeners.forEach(cb => cb(value));\n\t\t}\n\t};\n\n\tconst performSync = async () => {\n\t\tif (destroyed) return;\n\n\t\t// Validate Y.Doc before sync\n\t\tif (!ydoc || (ydoc as unknown as { destroyed?: boolean }).destroyed) {\n\t\t\tlogger.error(\"Cannot sync - Y.Doc is destroyed\", { documentId });\n\t\t\tsetPending(false);\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\tawait syncFn();\n\t\t\tretryCount = 0; // Reset on success\n\t\t\tsetPending(false);\n\t\t} catch (error) {\n\t\t\tlogger.error(\"Sync failed\", {\n\t\t\t\tdocumentId,\n\t\t\t\terror: error instanceof Error ? error.message : String(error),\n\t\t\t\tretryCount,\n\t\t\t});\n\n\t\t\t// Retry logic - keep pending true until all retries exhausted\n\t\t\tif (retryCount < MAX_RETRIES) {\n\t\t\t\tretryCount++;\n\t\t\t\tconst delay = RETRY_DELAY_MS * retryCount; // Exponential backoff\n\t\t\t\tlogger.debug(\"Scheduling retry\", { documentId, retryCount, delayMs: delay });\n\t\t\t\tretryTimeoutId = setTimeout(performSync, delay);\n\t\t\t\t// Keep pending = true during retries\n\t\t\t} else {\n\t\t\t\t// All retries exhausted - will retry on next local change\n\t\t\t\tlogger.warn(\"Sync retries exhausted, will retry on next change\", { documentId });\n\t\t\t\tsetPending(false);\n\t\t\t\tretryCount = 0;\n\t\t\t}\n\t\t}\n\t};\n\n\treturn {\n\t\tonLocalChange() {\n\t\t\tif (destroyed) return;\n\t\t\tif (timeoutId) clearTimeout(timeoutId);\n\t\t\tif (retryTimeoutId) clearTimeout(retryTimeoutId);\n\t\t\tretryCount = 0; // Reset retry count on new local change\n\t\t\tsetPending(true);\n\t\t\ttimeoutId = setTimeout(performSync, debounceMs);\n\t\t},\n\n\t\tonServerUpdate() {\n\t\t\t// Server updates don't require action - Yjs handles merging\n\t\t\t// This is kept for API compatibility if needed in future\n\t\t},\n\n\t\tisPending() {\n\t\t\treturn pending;\n\t\t},\n\n\t\tonPendingChange(callback: (pending: boolean) => void) {\n\t\t\tpendingListeners.add(callback);\n\t\t\treturn () => pendingListeners.delete(callback);\n\t\t},\n\n\t\tdestroy() {\n\t\t\tdestroyed = true;\n\t\t\tif (timeoutId) {\n\t\t\t\tclearTimeout(timeoutId);\n\t\t\t\ttimeoutId = null;\n\t\t\t}\n\t\t\tif (retryTimeoutId) {\n\t\t\t\tclearTimeout(retryTimeoutId);\n\t\t\t\tretryTimeoutId = null;\n\t\t\t}\n\t\t\tpendingListeners.clear();\n\t\t},\n\t};\n}\n\n// Per-collection sync managers to avoid cross-collection conflicts\nconst collectionSyncs = new Map<string, Map<string, DocumentSync>>();\n\nfunction getSyncsForCollection(collection: string): Map<string, DocumentSync> {\n\tlet syncs = collectionSyncs.get(collection);\n\tif (!syncs) {\n\t\tsyncs = new Map();\n\t\tcollectionSyncs.set(collection, syncs);\n\t}\n\treturn syncs;\n}\n\nexport function createSyncManager(collection: string) {\n\tconst syncs = getSyncsForCollection(collection);\n\n\treturn {\n\t\tregister(\n\t\t\tdocumentId: string,\n\t\t\tydoc: Y.Doc,\n\t\t\tsyncFn: () => Promise<void>,\n\t\t\tdebounceMs?: number,\n\t\t): DocumentSync {\n\t\t\tconst existing = syncs.get(documentId);\n\t\t\tif (existing) return existing;\n\n\t\t\tconst sync = createDocumentSync(documentId, ydoc, syncFn, debounceMs);\n\t\t\tsyncs.set(documentId, sync);\n\t\t\tlogger.debug(\"Sync registered\", { collection, documentId });\n\t\t\treturn sync;\n\t\t},\n\n\t\tget(documentId: string): DocumentSync | null {\n\t\t\treturn syncs.get(documentId) ?? null;\n\t\t},\n\n\t\tunregister(documentId: string): void {\n\t\t\tconst sync = syncs.get(documentId);\n\t\t\tif (sync) {\n\t\t\t\tsync.destroy();\n\t\t\t\tsyncs.delete(documentId);\n\t\t\t\tlogger.debug(\"Sync unregistered\", { collection, documentId });\n\t\t\t}\n\t\t},\n\n\t\tdestroy(): void {\n\t\t\tfor (const [, sync] of syncs) {\n\t\t\t\tsync.destroy();\n\t\t\t}\n\t\t\tsyncs.clear();\n\t\t\tcollectionSyncs.delete(collection);\n\t\t\tlogger.debug(\"Sync manager destroyed\", { collection });\n\t\t},\n\t};\n}\n\nexport type SyncManager = ReturnType<typeof createSyncManager>;\n","import * as Y from \"yjs\";\nimport type { Collection } from \"@tanstack/db\";\nimport { getLogger } from \"$/shared/logger\";\nimport { serializeYMapValue } from \"$/client/merge\";\nimport { getContext, hasContext } from \"$/client/services/context\";\nimport { createSyncManager, type SyncManager } from \"$/client/services/sync\";\n\nconst SERVER_ORIGIN = \"server\";\nconst noop = (): void => undefined;\n\nconst logger = getLogger([\"replicate\", \"prose\"]);\n\n// Per-collection sync managers\nconst syncManagers = new Map<string, SyncManager>();\n\nfunction getSyncManager(collection: string): SyncManager {\n\tlet manager = syncManagers.get(collection);\n\tif (!manager) {\n\t\tmanager = createSyncManager(collection);\n\t\tsyncManagers.set(collection, manager);\n\t}\n\treturn manager;\n}\n\nexport interface ProseObserverConfig {\n\tcollection: string;\n\tdocument: string;\n\tfield: string;\n\tfragment: Y.XmlFragment;\n\tydoc: Y.Doc;\n\tymap: Y.Map<unknown>;\n\tcollectionRef: Collection<any>;\n\tdebounceMs?: number;\n}\n\nfunction createSyncFn(\n\tdocument: string,\n\tydoc: Y.Doc,\n\tymap: Y.Map<unknown>,\n\tcollectionRef: Collection<any>,\n): () => Promise<void> {\n\treturn async () => {\n\t\tconst material = serializeYMapValue(ymap);\n\t\tconst delta = Y.encodeStateAsUpdateV2(ydoc);\n\t\tconst bytes = delta.buffer as ArrayBuffer;\n\n\t\t// Fire-and-forget: TanStack DB handles persistence independently.\n\t\t// Yjs CRDTs ensure eventual consistency, so we don't need to await.\n\t\t// This removes the network round-trip blocking from the sync path.\n\t\tcollectionRef.update(\n\t\t\tdocument,\n\t\t\t{ metadata: { contentSync: { bytes, material } } },\n\t\t\t(draft: any) => {\n\t\t\t\tdraft.timestamp = Date.now();\n\t\t\t},\n\t\t);\n\t};\n}\n\nexport function observeFragment(config: ProseObserverConfig): () => void {\n\tconst { collection, document, field, fragment, ydoc, ymap, collectionRef, debounceMs } = config;\n\n\tif (!hasContext(collection)) {\n\t\tlogger.warn(\"Cannot observe fragment - collection not initialized\", { collection, document });\n\t\treturn noop;\n\t}\n\n\tconst ctx = getContext(collection);\n\n\tconst existingCleanup = ctx.fragmentObservers.get(document);\n\tif (existingCleanup) {\n\t\tlogger.debug(\"Fragment already being observed\", { collection, document, field });\n\t\treturn existingCleanup;\n\t}\n\n\tconst syncFn = createSyncFn(document, ydoc, ymap, collectionRef);\n\tconst syncManager = getSyncManager(collection);\n\n\t// Register sync - this is synchronous, no error handling needed\n\tconst sync = syncManager.register(document, ydoc, syncFn, debounceMs);\n\tlogger.debug(\"Fragment observer registered\", { collection, document, field });\n\n\tconst observerHandler = (_events: Y.YEvent<any>[], transaction: Y.Transaction) => {\n\t\tif (transaction.origin === SERVER_ORIGIN) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Trigger local change sync\n\t\tsync.onLocalChange();\n\t};\n\n\tfragment.observeDeep(observerHandler);\n\n\tconst cleanup = () => {\n\t\tfragment.unobserveDeep(observerHandler);\n\t\tsyncManager.unregister(document);\n\t\tctx.fragmentObservers.delete(document);\n\t\tlogger.debug(\"Fragment observer cleaned up\", { collection, document, field });\n\t};\n\n\tctx.fragmentObservers.set(document, cleanup);\n\n\treturn cleanup;\n}\n\nexport function isPending(collection: string, document: string): boolean {\n\tconst syncManager = syncManagers.get(collection);\n\tif (!syncManager) return false;\n\n\tconst sync = syncManager.get(document);\n\treturn sync?.isPending() ?? false;\n}\n\nexport function subscribePending(\n\tcollection: string,\n\tdocument: string,\n\tcallback: (pending: boolean) => void,\n): () => void {\n\tconst syncManager = syncManagers.get(collection);\n\tif (!syncManager) return noop;\n\n\tconst sync = syncManager.get(document);\n\tif (!sync) return noop;\n\n\treturn sync.onPendingChange(callback);\n}\n\nexport function cleanup(collection: string): void {\n\tconst syncManager = syncManagers.get(collection);\n\tif (syncManager) {\n\t\tsyncManager.destroy();\n\t\tsyncManagers.delete(collection);\n\t}\n\n\tif (!hasContext(collection)) return;\n\tconst ctx = getContext(collection);\n\n\tfor (const [, cleanupFn] of ctx.fragmentObservers) {\n\t\tcleanupFn();\n\t}\n\tctx.fragmentObservers.clear();\n\n\tlogger.debug(\"Prose cleanup complete\", { collection });\n}\n","import * as Y from \"yjs\";\nimport { Awareness } from \"y-protocols/awareness\";\nimport type { ConvexClient } from \"convex/browser\";\nimport type { FunctionReference } from \"convex/server\";\nimport type { AnonymousPresenceConfig, UserIdentity } from \"$/client/identity\";\n\nconst DEFAULT_HEARTBEAT_MS = 10000;\nconst DEFAULT_THROTTLE_MS = 50;\n\nconst DEFAULT_ADJECTIVES = [\n\t\"Swift\",\n\t\"Bright\",\n\t\"Calm\",\n\t\"Bold\",\n\t\"Keen\",\n\t\"Quick\",\n\t\"Warm\",\n\t\"Cool\",\n\t\"Sharp\",\n\t\"Gentle\",\n];\n\nconst DEFAULT_NOUNS = [\n\t\"Fox\",\n\t\"Owl\",\n\t\"Bear\",\n\t\"Wolf\",\n\t\"Hawk\",\n\t\"Deer\",\n\t\"Lynx\",\n\t\"Crow\",\n\t\"Hare\",\n\t\"Seal\",\n];\n\nconst DEFAULT_COLORS = [\n\t\"#9F5944\",\n\t\"#A9704D\",\n\t\"#B08650\",\n\t\"#8A7D3F\",\n\t\"#6E7644\",\n\t\"#8C4A42\",\n\t\"#9E7656\",\n\t\"#9A5240\",\n\t\"#987C4A\",\n\t\"#7A8B6E\",\n];\n\ninterface PresenceApi {\n\tpresence: FunctionReference<\"mutation\">;\n\tsession: FunctionReference<\"query\">;\n}\n\nexport interface PresenceState {\n\tlocal: UserIdentity | null;\n\tremote: UserIdentity[];\n}\n\nexport interface Presence {\n\tjoin(options?: { cursor?: unknown }): void;\n\tleave(): void;\n\tupdate(options: { cursor?: unknown }): void;\n\tget(): PresenceState;\n\tsubscribe(callback: (state: PresenceState) => void): () => void;\n}\n\nexport interface PresenceConfig {\n\tconvexClient: ConvexClient;\n\tapi: PresenceApi;\n\tdocument: string;\n\tclient: string;\n\tydoc: Y.Doc;\n\theartbeatMs?: number;\n\tthrottleMs?: number;\n\tsyncReady?: Promise<void>;\n\tuser?: () => UserIdentity | undefined;\n\tanonymousPresence?: AnonymousPresenceConfig;\n}\n\nexport interface PresenceProvider extends Presence {\n\tawareness: Awareness;\n\tdestroy(): void;\n}\n\ntype PresenceLifecycleState = \"idle\" | \"joining\" | \"active\" | \"leaving\" | \"destroyed\";\n\ninterface PresencePayload {\n\taction: \"join\" | \"leave\";\n\tcursor?: unknown;\n\tuser?: string;\n\tprofile?: { name?: string; color?: string; avatar?: string };\n\tvector?: ArrayBuffer;\n}\n\ninterface FlightStatus {\n\tinFlight: boolean;\n\tpending: PresencePayload | null;\n}\n\nexport function hashStringToNumber(str: string): number {\n\tlet hash = 0;\n\tfor (let i = 0; i < str.length; i++) {\n\t\tconst char = str.charCodeAt(i);\n\t\thash = (hash << 5) - hash + char;\n\t\thash = hash & hash;\n\t}\n\treturn Math.abs(hash);\n}\n\nexport function getStableAnonName(clientId: string, config?: AnonymousPresenceConfig): string {\n\tconst adjectives = config?.adjectives ?? DEFAULT_ADJECTIVES;\n\tconst nouns = config?.nouns ?? DEFAULT_NOUNS;\n\tconst hash = hashStringToNumber(clientId);\n\tconst adj = adjectives[hash % adjectives.length];\n\tconst noun = nouns[(hash >> 4) % nouns.length];\n\treturn `${adj} ${noun}`;\n}\n\nexport function getStableAnonColor(clientId: string, config?: AnonymousPresenceConfig): string {\n\tconst colors = config?.colors ?? DEFAULT_COLORS;\n\tconst hash = hashStringToNumber(clientId);\n\treturn colors[(hash >> 8) % colors.length];\n}\n\nexport function createPresence(config: PresenceConfig): PresenceProvider {\n\tconst {\n\t\tconvexClient,\n\t\tapi,\n\t\tdocument,\n\t\tclient,\n\t\tydoc,\n\t\theartbeatMs = DEFAULT_HEARTBEAT_MS,\n\t\tthrottleMs = DEFAULT_THROTTLE_MS,\n\t\tsyncReady,\n\t\tuser: userGetter,\n\t\tanonymousPresence,\n\t} = config;\n\n\tconst awareness = new Awareness(ydoc);\n\tconst resolvedUser = userGetter?.();\n\n\tif (resolvedUser) {\n\t\tawareness.setLocalStateField(\"user\", resolvedUser);\n\t}\n\n\tlet state: PresenceLifecycleState = \"idle\";\n\tlet visible = true;\n\tlet heartbeatTimer: ReturnType<typeof setInterval> | null = null;\n\tlet throttleTimer: ReturnType<typeof setTimeout> | null = null;\n\tlet startTimeout: ReturnType<typeof setTimeout> | null = null;\n\tlet unsubscribeCursors: (() => void) | undefined;\n\tlet unsubscribeVisibility: (() => void) | undefined;\n\tlet unsubscribePageHide: (() => void) | undefined;\n\n\tconst flightStatus: FlightStatus = {\n\t\tinFlight: false,\n\t\tpending: null,\n\t};\n\n\tconst remoteClientIds = new Map<string, number>();\n\tconst subscribers = new Set<(state: PresenceState) => void>();\n\n\tconst getVector = (): ArrayBuffer | undefined => {\n\t\treturn Y.encodeStateVector(ydoc).buffer as ArrayBuffer;\n\t};\n\n\tconst extractCursorFromState = (\n\t\tawarenessState: Record<string, unknown> | null,\n\t): { anchor: unknown; head: unknown } | undefined => {\n\t\tif (!awarenessState) return undefined;\n\n\t\tconst cursor = awarenessState.cursor as { anchor?: unknown; head?: unknown } | undefined | null;\n\n\t\tif (cursor?.anchor === undefined || cursor.head === undefined) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\ttry {\n\t\t\treturn {\n\t\t\t\tanchor: JSON.parse(JSON.stringify(cursor.anchor)),\n\t\t\t\thead: JSON.parse(JSON.stringify(cursor.head)),\n\t\t\t};\n\t\t} catch {\n\t\t\treturn undefined;\n\t\t}\n\t};\n\n\tconst extractUserFromState = (\n\t\tawarenessState: Record<string, unknown> | null,\n\t): {\n\t\tuser?: string;\n\t\tprofile?: { name?: string; color?: string; avatar?: string };\n\t} => {\n\t\tif (!awarenessState) return {};\n\n\t\tconst userState = awarenessState.user as\n\t\t\t| { id?: string; name?: string; color?: string; avatar?: string; [key: string]: unknown }\n\t\t\t| undefined;\n\n\t\tif (userState) {\n\t\t\tconst result: {\n\t\t\t\tuser?: string;\n\t\t\t\tprofile?: { name?: string; color?: string; avatar?: string };\n\t\t\t} = {};\n\n\t\t\tif (typeof userState.id === \"string\") {\n\t\t\t\tresult.user = userState.id;\n\t\t\t}\n\n\t\t\tconst profile: { name?: string; color?: string; avatar?: string } = {};\n\t\t\tif (typeof userState.name === \"string\") profile.name = userState.name;\n\t\t\tif (typeof userState.color === \"string\") profile.color = userState.color;\n\t\t\tif (typeof userState.avatar === \"string\") profile.avatar = userState.avatar;\n\n\t\t\tif (Object.keys(profile).length > 0) {\n\t\t\t\tresult.profile = profile;\n\t\t\t}\n\n\t\t\treturn result;\n\t\t}\n\n\t\treturn {};\n\t};\n\n\tconst buildJoinPayload = (cursorOverride?: unknown): PresencePayload => {\n\t\tconst localState = awareness.getLocalState();\n\t\tconst cursor = cursorOverride ?? extractCursorFromState(localState);\n\t\tconst { user: userId, profile } = extractUserFromState(localState);\n\t\tconst vector = getVector();\n\n\t\treturn {\n\t\t\taction: \"join\",\n\t\t\tcursor,\n\t\t\tuser: userId,\n\t\t\tprofile,\n\t\t\tvector,\n\t\t};\n\t};\n\n\tconst executePresence = async (payload: PresencePayload): Promise<void> => {\n\t\tawait convexClient.mutation(api.presence, {\n\t\t\tdocument,\n\t\t\tclient,\n\t\t\taction: payload.action,\n\t\t\tcursor: payload.cursor,\n\t\t\tuser: payload.user,\n\t\t\tprofile: payload.profile,\n\t\t\tinterval: payload.action === \"join\" ? heartbeatMs : undefined,\n\t\t\tvector: payload.vector,\n\t\t});\n\t};\n\n\tconst isDestroyed = (): boolean => state === \"destroyed\";\n\n\tconst sendWithSingleFlight = async (payload: PresencePayload): Promise<void> => {\n\t\tif (isDestroyed()) return;\n\n\t\tif (flightStatus.inFlight) {\n\t\t\tflightStatus.pending = payload;\n\t\t\treturn;\n\t\t}\n\n\t\tflightStatus.inFlight = true;\n\n\t\ttry {\n\t\t\tawait executePresence(payload);\n\t\t} finally {\n\t\t\twhile (flightStatus.pending && !isDestroyed()) {\n\t\t\t\tconst next = flightStatus.pending;\n\t\t\t\tflightStatus.pending = null;\n\t\t\t\ttry {\n\t\t\t\t\tawait executePresence(next);\n\t\t\t\t} catch {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tflightStatus.inFlight = false;\n\t\t}\n\t};\n\n\tconst transitionTo = (newState: PresenceLifecycleState): boolean => {\n\t\tconst validTransitions: Record<PresenceLifecycleState, PresenceLifecycleState[]> = {\n\t\t\tidle: [\"joining\", \"destroyed\"],\n\t\t\tjoining: [\"active\", \"leaving\", \"destroyed\"],\n\t\t\tactive: [\"leaving\", \"destroyed\"],\n\t\t\tleaving: [\"idle\", \"joining\", \"destroyed\"],\n\t\t\tdestroyed: [],\n\t\t};\n\n\t\tif (!validTransitions[state].includes(newState)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tstate = newState;\n\t\treturn true;\n\t};\n\n\tconst notifySubscribers = (): void => {\n\t\tconst presenceState = getPresenceState();\n\t\tsubscribers.forEach(cb => cb(presenceState));\n\t};\n\n\tconst getPresenceState = (): PresenceState => {\n\t\tconst localState = awareness.getLocalState();\n\t\tconst localUser = localState?.user as UserIdentity | undefined;\n\n\t\tconst remote: UserIdentity[] = [];\n\t\tfor (const [clientStr] of remoteClientIds) {\n\t\t\tconst clientId = remoteClientIds.get(clientStr);\n\t\t\tif (clientId !== undefined) {\n\t\t\t\tconst remoteState = awareness.states.get(clientId);\n\t\t\t\tif (remoteState?.user) {\n\t\t\t\t\tremote.push(remoteState.user as UserIdentity);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tlocal: localUser ?? null,\n\t\t\tremote,\n\t\t};\n\t};\n\n\tconst joinPresence = (cursorOverride?: unknown): void => {\n\t\tif (state === \"destroyed\" || !visible) return;\n\n\t\tif (state === \"idle\" || state === \"leaving\") {\n\t\t\ttransitionTo(\"joining\");\n\t\t}\n\n\t\tconst payload = buildJoinPayload(cursorOverride);\n\t\tsendWithSingleFlight(payload).then(() => {\n\t\t\tif (state === \"joining\") {\n\t\t\t\ttransitionTo(\"active\");\n\t\t\t}\n\t\t});\n\t};\n\n\tconst leavePresence = (): void => {\n\t\tif (state === \"destroyed\") return;\n\t\tif (state === \"idle\") return;\n\n\t\ttransitionTo(\"leaving\");\n\n\t\tsendWithSingleFlight({ action: \"leave\" }).then(() => {\n\t\t\tif (state === \"leaving\") {\n\t\t\t\ttransitionTo(\"idle\");\n\t\t\t}\n\t\t});\n\t};\n\n\tconst throttledJoin = (): void => {\n\t\tif (throttleTimer) return;\n\t\tif (state === \"destroyed\") return;\n\n\t\tthrottleTimer = setTimeout(() => {\n\t\t\tthrottleTimer = null;\n\t\t\tif (visible) {\n\t\t\t\tjoinPresence();\n\t\t\t}\n\t\t}, throttleMs);\n\t};\n\n\tconst onLocalAwarenessUpdate = (\n\t\tchanges: { added: number[]; updated: number[]; removed: number[] },\n\t\torigin: unknown,\n\t): void => {\n\t\tif (origin === \"remote\") return;\n\t\tif (state === \"destroyed\") return;\n\n\t\tconst localClientId = awareness.clientID;\n\t\tif (changes.added.includes(localClientId) || changes.updated.includes(localClientId)) {\n\t\t\tthrottledJoin();\n\t\t}\n\t};\n\n\tconst subscribeToPresence = (): void => {\n\t\tunsubscribeCursors = convexClient.onUpdate(\n\t\t\tapi.session,\n\t\t\t{ document, connected: true, exclude: client },\n\t\t\t(\n\t\t\t\tremotes: {\n\t\t\t\t\tclient: string;\n\t\t\t\t\tdocument: string;\n\t\t\t\t\tuser?: string;\n\t\t\t\t\tprofile?: { name?: string; color?: string; avatar?: string };\n\t\t\t\t\tcursor?: { anchor: unknown; head: unknown; field?: string };\n\t\t\t\t}[],\n\t\t\t) => {\n\t\t\t\tif (state === \"destroyed\") return;\n\n\t\t\t\tconst validRemotes = remotes.filter(r => r.document === document);\n\t\t\t\tconst currentRemotes = new Set<string>();\n\n\t\t\t\tfor (const remote of validRemotes) {\n\t\t\t\t\tcurrentRemotes.add(remote.client);\n\n\t\t\t\t\tlet remoteClientId = remoteClientIds.get(remote.client);\n\t\t\t\t\tif (!remoteClientId) {\n\t\t\t\t\t\tremoteClientId = hashStringToNumber(remote.client);\n\t\t\t\t\t\tremoteClientIds.set(remote.client, remoteClientId);\n\t\t\t\t\t}\n\n\t\t\t\t\tconst remoteState: Record<string, unknown> = {\n\t\t\t\t\t\tuser: {\n\t\t\t\t\t\t\tid: remote.user,\n\t\t\t\t\t\t\tname:\n\t\t\t\t\t\t\t\tremote.profile?.name ??\n\t\t\t\t\t\t\t\tremote.user ??\n\t\t\t\t\t\t\t\tgetStableAnonName(remote.client, anonymousPresence),\n\t\t\t\t\t\t\tcolor: remote.profile?.color ?? getStableAnonColor(remote.client, anonymousPresence),\n\t\t\t\t\t\t\tavatar: remote.profile?.avatar,\n\t\t\t\t\t\t\tclientId: remote.client,\n\t\t\t\t\t\t},\n\t\t\t\t\t};\n\n\t\t\t\t\tif (remote.cursor) {\n\t\t\t\t\t\tremoteState.cursor = remote.cursor;\n\t\t\t\t\t}\n\n\t\t\t\t\tawareness.states.set(remoteClientId, remoteState);\n\t\t\t\t}\n\n\t\t\t\tfor (const [clientStr, clientId] of remoteClientIds) {\n\t\t\t\t\tif (!currentRemotes.has(clientStr)) {\n\t\t\t\t\t\tawareness.states.delete(clientId);\n\t\t\t\t\t\tremoteClientIds.delete(clientStr);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tawareness.emit(\"update\", [\n\t\t\t\t\t{ added: [], updated: Array.from(remoteClientIds.values()), removed: [] },\n\t\t\t\t\t\"remote\",\n\t\t\t\t]);\n\n\t\t\t\tnotifySubscribers();\n\t\t\t},\n\t\t);\n\t};\n\n\tconst setupVisibilityHandler = (): void => {\n\t\tif (typeof globalThis.document === \"undefined\") return;\n\n\t\tconst handler = (): void => {\n\t\t\tif (state === \"destroyed\") return;\n\n\t\t\tconst wasVisible = visible;\n\t\t\tvisible = globalThis.document.visibilityState === \"visible\";\n\n\t\t\tif (wasVisible && !visible) {\n\t\t\t\tleavePresence();\n\t\t\t} else if (!wasVisible && visible && state === \"active\") {\n\t\t\t\tjoinPresence();\n\t\t\t}\n\t\t};\n\n\t\tglobalThis.document.addEventListener(\"visibilitychange\", handler);\n\t\tunsubscribeVisibility = () => {\n\t\t\tglobalThis.document.removeEventListener(\"visibilitychange\", handler);\n\t\t};\n\t};\n\n\tconst setupPageHideHandler = (): void => {\n\t\tif (typeof globalThis.window === \"undefined\") return;\n\n\t\tconst handler = (e: PageTransitionEvent): void => {\n\t\t\tif (e.persisted) return;\n\t\t\tif (state === \"destroyed\") return;\n\n\t\t\tconvexClient.mutation(api.presence, {\n\t\t\t\tdocument,\n\t\t\t\tclient,\n\t\t\t\taction: \"leave\" as const,\n\t\t\t});\n\t\t};\n\n\t\tglobalThis.window.addEventListener(\"pagehide\", handler);\n\t\tunsubscribePageHide = () => {\n\t\t\tglobalThis.window.removeEventListener(\"pagehide\", handler);\n\t\t};\n\t};\n\n\tconst startHeartbeat = (): void => {\n\t\tif (state === \"destroyed\") return;\n\n\t\theartbeatTimer = setInterval(() => {\n\t\t\tif (state !== \"destroyed\" && visible && state === \"active\") {\n\t\t\t\tjoinPresence();\n\t\t\t}\n\t\t}, heartbeatMs);\n\t};\n\n\tconst stopHeartbeat = (): void => {\n\t\tif (heartbeatTimer) {\n\t\t\tclearInterval(heartbeatTimer);\n\t\t\theartbeatTimer = null;\n\t\t}\n\t};\n\n\tawareness.on(\"update\", onLocalAwarenessUpdate);\n\tsubscribeToPresence();\n\tsetupVisibilityHandler();\n\tsetupPageHideHandler();\n\n\tconst initHeartbeat = async (): Promise<void> => {\n\t\tif (syncReady) {\n\t\t\tawait syncReady;\n\t\t}\n\t\tif (state !== \"destroyed\") {\n\t\t\tstartHeartbeat();\n\t\t}\n\t};\n\n\tstartTimeout = setTimeout(() => {\n\t\tinitHeartbeat();\n\t}, 0);\n\n\treturn {\n\t\tawareness,\n\n\t\tjoin(options?: { cursor?: unknown }): void {\n\t\t\tjoinPresence(options?.cursor);\n\t\t},\n\n\t\tleave(): void {\n\t\t\tleavePresence();\n\t\t},\n\n\t\tupdate(options: { cursor?: unknown }): void {\n\t\t\tif (state === \"destroyed\") return;\n\t\t\tawareness.setLocalStateField(\"cursor\", options.cursor);\n\t\t},\n\n\t\tget(): PresenceState {\n\t\t\treturn getPresenceState();\n\t\t},\n\n\t\tsubscribe(callback: (state: PresenceState) => void): () => void {\n\t\t\tsubscribers.add(callback);\n\t\t\tcallback(getPresenceState());\n\t\t\treturn () => subscribers.delete(callback);\n\t\t},\n\n\t\tdestroy(): void {\n\t\t\tif (state === \"destroyed\") return;\n\t\t\ttransitionTo(\"destroyed\");\n\n\t\t\tif (startTimeout) {\n\t\t\t\tclearTimeout(startTimeout);\n\t\t\t\tstartTimeout = null;\n\t\t\t}\n\t\t\tif (throttleTimer) {\n\t\t\t\tclearTimeout(throttleTimer);\n\t\t\t\tthrottleTimer = null;\n\t\t\t}\n\n\t\t\tflightStatus.pending = null;\n\t\t\tsubscribers.clear();\n\n\t\t\tstopHeartbeat();\n\t\t\tawareness.off(\"update\", onLocalAwarenessUpdate);\n\t\t\tunsubscribeCursors?.();\n\t\t\tunsubscribeVisibility?.();\n\t\t\tunsubscribePageHide?.();\n\n\t\t\tfor (const clientId of remoteClientIds.values()) {\n\t\t\t\tawareness.states.delete(clientId);\n\t\t\t}\n\t\t\tremoteClientIds.clear();\n\t\t\tawareness.emit(\"update\", [{ added: [], updated: [], removed: [] }, \"remote\"]);\n\n\t\t\tconvexClient.mutation(api.presence, {\n\t\t\t\tdocument,\n\t\t\t\tclient,\n\t\t\t\taction: \"leave\" as const,\n\t\t\t});\n\n\t\t\tawareness.destroy();\n\t\t},\n\t};\n}\n","import * as Y from \"yjs\";\nimport type { Persistence, PersistenceProvider } from \"$/client/persistence/types\";\nimport type { ConvexClient } from \"convex/browser\";\nimport { getFunctionName, type FunctionReference } from \"convex/server\";\nimport {\n\tcreateCollection,\n\ttype CollectionConfig,\n\ttype Collection,\n\ttype NonSingleResult,\n\ttype BaseCollectionConfig,\n} from \"@tanstack/db\";\nimport type { GenericValidator } from \"convex/values\";\nimport type { VersionedSchema } from \"$/server/migration\";\nimport type { MigrationErrorHandler, ClientMigrationMap } from \"$/client/migration\";\nimport { runMigrations } from \"$/client/migration\";\nimport { findProseFields } from \"$/client/validators\";\nimport { ProseError, NonRetriableError } from \"$/client/errors\";\nimport { createSeqService, type Seq } from \"$/client/services/seq\";\nimport { getClientId } from \"$/client/services/session\";\nimport { createReplicateOps, type BoundReplicateOps } from \"$/client/ops\";\nimport { isDoc, fragmentFromJSON } from \"$/client/merge\";\nimport { createDocumentManager, serializeDocument, extractAllDocuments } from \"$/client/documents\";\nimport { createDeleteDelta, applyDeleteMarkerToDoc } from \"$/client/deltas\";\nimport * as prose from \"$/client/prose\";\nimport { getLogger } from \"$/shared/logger\";\nimport {\n\tinitContext,\n\tgetContext,\n\thasContext,\n\tupdateContext,\n\tdeleteContext,\n} from \"$/client/services/context\";\nimport {\n\tcreatePresence,\n\ttype PresenceProvider,\n\ttype Presence,\n\ttype PresenceState,\n} from \"$/client/services/presence\";\n\nexport type { Presence as DocumentPresence, PresenceState };\nimport type { AnonymousPresenceConfig, UserIdentity } from \"$/client/identity\";\nimport { Awareness } from \"y-protocols/awareness\";\n\nenum YjsOrigin {\n\tLocal = \"local\",\n\tFragment = \"fragment\",\n\tServer = \"server\",\n}\n\nconst logger = getLogger([\"replicate\", \"collection\"]);\n\nimport type { ProseFields } from \"$/shared\";\n\ninterface HttpError extends Error {\n\tstatus?: number;\n}\n\n/** Mutation data passed by TanStack DB transaction handlers */\ninterface CollectionMutation<T> {\n\tkey: string | number;\n\tmodified: T;\n\toriginal?: T | Record<string, never>;\n\tchanges?: Partial<T>;\n\tmetadata?: unknown;\n}\n\ninterface ContentSyncMetadata {\n\tbytes: ArrayBuffer;\n\tmaterial: unknown;\n}\n\n/** Transaction wrapper containing mutations array */\ninterface CollectionTransaction<T> {\n\ttransaction: {\n\t\tmutations: CollectionMutation<T>[];\n\t};\n}\n\nfunction handleMutationError(error: unknown): never {\n\tconst httpError = error as HttpError;\n\n\tif (httpError?.status === 401 || httpError?.status === 403) {\n\t\tthrow new NonRetriableError(\"Authentication failed\");\n\t}\n\tif (httpError?.status === 422) {\n\t\tthrow new NonRetriableError(\"Validation error\");\n\t}\n\tthrow error;\n}\n\n/** Server-rendered material data for SSR hydration */\nexport interface Materialized<T> {\n\tdocuments: readonly T[];\n\tcursor?: Seq;\n\tcount?: number;\n\tcrdt?: Record<string, { bytes: ArrayBuffer; seq: number }>;\n}\n\nexport interface PaginatedPage<T> {\n\tpage: readonly T[];\n\tisDone: boolean;\n\tcontinueCursor: string;\n}\n\nexport interface PaginatedMaterial<T> {\n\tpages: readonly PaginatedPage<T>[];\n\tcursor: string;\n\tisDone: boolean;\n}\n\nexport interface PaginationConfig {\n\tpageSize?: number;\n}\n\nexport type PaginationStatus = \"idle\" | \"busy\" | \"done\" | \"error\";\n\nexport interface PaginationState {\n\tstatus: PaginationStatus;\n\tcount: number;\n\tcursor: string | null;\n\terror?: Error;\n}\n\ninterface ConvexCollectionApi {\n\tmaterial: FunctionReference<\"query\">;\n\tdelta: FunctionReference<\"query\">;\n\treplicate: FunctionReference<\"mutation\">;\n\tpresence: FunctionReference<\"mutation\">;\n\tsession: FunctionReference<\"query\">;\n}\n\nexport interface ConvexCollectionConfig<T extends object = object> extends Omit<\n\tBaseCollectionConfig<T, string, never>,\n\t\"schema\"\n> {\n\tvalidator?: GenericValidator;\n\tconvexClient: ConvexClient;\n\tapi: ConvexCollectionApi;\n\tpersistence: Persistence;\n\tmaterial?: Materialized<T>;\n\tuser?: () => UserIdentity | undefined;\n\t/**\n\t * Configuration for anonymous presence names and colors.\n\t * Allows customizing the adjectives, nouns, and colors used\n\t * when generating anonymous user identities for presence.\n\t */\n\tanonymousPresence?: AnonymousPresenceConfig;\n}\n\n/**\n * Binding returned by collection.utils.prose() for collaborative editing.\n *\n * Compatible with TipTap's Collaboration/CollaborationCursor and BlockNote's\n * collaboration config. The editor handles undo/redo internally via y-prosemirror.\n */\nexport interface EditorBinding {\n\t/** Yjs XmlFragment for content sync */\n\treadonly fragment: Y.XmlFragment;\n\n\t/**\n\t * Provider with Yjs Awareness for cursor/presence sync.\n\t * Pass to CollaborationCursor.configure({ provider: binding.provider })\n\t * or BlockNote's collaboration.provider\n\t */\n\treadonly provider: {\n\t\treadonly awareness: Awareness;\n\t\treadonly document: Y.Doc;\n\t};\n\n\t/** Whether there are unsaved local changes */\n\treadonly pending: boolean;\n\n\t/** Subscribe to pending state changes */\n\tonPendingChange(callback: (pending: boolean) => void): () => void;\n\n\t/** Cleanup - call when unmounting editor */\n\tdestroy(): void;\n}\n\nexport interface ProseOptions {\n\t/** User identity getter for collaborative presence */\n\tuser?: () => UserIdentity | undefined;\n\t/**\n\t * Debounce delay in milliseconds before syncing changes to server.\n\t * Local changes are batched during this window for efficiency.\n\t * @default 50\n\t */\n\tdebounceMs?: number;\n\t/**\n\t * Throttle delay in milliseconds for presence/cursor position updates.\n\t * Lower values mean faster cursor sync but more network traffic.\n\t * @default 50\n\t */\n\tthrottleMs?: number;\n}\n\ninterface ConvexCollectionUtils<T extends object> {\n\tprose(document: string, field: ProseFields<T>, options?: ProseOptions): Promise<EditorBinding>;\n}\n\nexport interface SessionInfo {\n\tclient: string;\n\tdocument: string;\n\tuser?: string;\n\tprofile?: { name?: string; color?: string; avatar?: string };\n\tcursor?: unknown;\n\tconnected: boolean;\n}\n\nexport interface SessionAPI {\n\tget(docId?: string): SessionInfo[];\n\tsubscribe(callback: (sessions: SessionInfo[]) => void): () => void;\n}\n\nexport interface DocumentHandle<T extends object> {\n\treadonly id: string;\n\treadonly presence: Presence;\n\treadonly awareness: Awareness;\n\tprose(field: ProseFields<T>, options?: ProseOptions): Promise<EditorBinding>;\n}\n\ninterface ConvexCollectionExtensions<T extends object> {\n\tdoc(id: string): DocumentHandle<T>;\n\treadonly session: SessionAPI;\n}\n\nexport function convexCollectionOptions<T extends object = object>(\n\tconfig: ConvexCollectionConfig<T>,\n): CollectionConfig<T, string, never, ConvexCollectionUtils<T>> & {\n\tid: string;\n\tutils: ConvexCollectionUtils<T>;\n\textensions: ConvexCollectionExtensions<T>;\n} {\n\tconst {\n\t\tvalidator,\n\t\tgetKey,\n\t\tmaterial,\n\t\tconvexClient,\n\t\tapi,\n\t\tpersistence,\n\t\tuser: userGetter,\n\t\tanonymousPresence,\n\t} = config;\n\n\tconst functionPath = getFunctionName(api.delta);\n\tconst collection = functionPath.split(\":\")[0];\n\tif (!collection) {\n\t\tthrow new Error(\"Could not extract collection name from api.delta function reference\");\n\t}\n\n\tconst proseFields: string[] = validator ? findProseFields(validator) : [];\n\n\t// DataType is 'any' in implementation - type safety comes from overload signatures\n\ttype DataType = any;\n\t// Create a Set for O(1) lookup of prose fields\n\tconst proseFieldSet = new Set<string>(proseFields);\n\n\tconst utils: ConvexCollectionUtils<DataType> = {\n\t\tasync prose(\n\t\t\tdocument: string,\n\t\t\tfield: ProseFields<DataType>,\n\t\t\toptions?: ProseOptions,\n\t\t): Promise<EditorBinding> {\n\t\t\tconst fieldStr = field;\n\n\t\t\tif (!proseFieldSet.has(fieldStr)) {\n\t\t\t\tthrow new ProseError({\n\t\t\t\t\tdocument,\n\t\t\t\t\tfield: fieldStr,\n\t\t\t\t\tcollection,\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tlet ctx = hasContext(collection) ? getContext(collection) : null;\n\n\t\t\tif (!ctx) {\n\t\t\t\tawait new Promise<void>((resolve, reject) => {\n\t\t\t\t\tconst maxWait = 10000;\n\t\t\t\t\tconst startTime = Date.now();\n\t\t\t\t\tconst check = setInterval(() => {\n\t\t\t\t\t\tif (hasContext(collection)) {\n\t\t\t\t\t\t\tclearInterval(check);\n\t\t\t\t\t\t\tresolve();\n\t\t\t\t\t\t} else if (Date.now() - startTime > maxWait) {\n\t\t\t\t\t\t\tclearInterval(check);\n\t\t\t\t\t\t\treject(\n\t\t\t\t\t\t\t\tnew ProseError({\n\t\t\t\t\t\t\t\t\tdocument,\n\t\t\t\t\t\t\t\t\tfield: fieldStr,\n\t\t\t\t\t\t\t\t\tcollection,\n\t\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}, 10);\n\t\t\t\t});\n\t\t\t\tctx = hasContext(collection) ? getContext(collection) : null;\n\t\t\t}\n\n\t\t\tif (!ctx) {\n\t\t\t\tthrow new ProseError({\n\t\t\t\t\tdocument,\n\t\t\t\t\tfield: fieldStr,\n\t\t\t\t\tcollection,\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tconst fragment = ctx.docManager.getFragment(document, fieldStr);\n\t\t\tif (!fragment) {\n\t\t\t\tthrow new ProseError({\n\t\t\t\t\tdocument,\n\t\t\t\t\tfield: fieldStr,\n\t\t\t\t\tcollection,\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tconst subdoc = ctx.docManager.get(document);\n\t\t\tif (!subdoc) {\n\t\t\t\tthrow new ProseError({\n\t\t\t\t\tdocument,\n\t\t\t\t\tfield: fieldStr,\n\t\t\t\t\tcollection,\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tconst collectionRef = ctx.ref;\n\t\t\tif (collectionRef) {\n\t\t\t\tprose.observeFragment({\n\t\t\t\t\tcollection,\n\t\t\t\t\tdocument,\n\t\t\t\t\tfield: fieldStr,\n\t\t\t\t\tfragment,\n\t\t\t\t\tydoc: subdoc,\n\t\t\t\t\tymap: ctx.docManager.getFields(document)!,\n\t\t\t\t\tcollectionRef,\n\t\t\t\t\tdebounceMs: options?.debounceMs,\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tconst storedConvexClient = ctx.client;\n\t\t\tconst storedApi = ctx.api;\n\t\t\tconst storedClientId = ctx.clientId;\n\n\t\t\tlet presenceProvider: PresenceProvider | null = null;\n\t\t\tconst hasPresenceApi = storedApi?.session && storedApi?.presence;\n\t\t\tif (storedConvexClient && hasPresenceApi && storedClientId) {\n\t\t\t\tpresenceProvider = createPresence({\n\t\t\t\t\tconvexClient: storedConvexClient,\n\t\t\t\t\tapi: {\n\t\t\t\t\t\tpresence: storedApi.presence!,\n\t\t\t\t\t\tsession: storedApi.session!,\n\t\t\t\t\t},\n\t\t\t\t\tdocument,\n\t\t\t\t\tclient: storedClientId,\n\t\t\t\t\tydoc: subdoc,\n\t\t\t\t\tsyncReady: ctx.synced,\n\t\t\t\t\tuser: options?.user ?? ctx.userGetter,\n\t\t\t\t\tthrottleMs: options?.throttleMs,\n\t\t\t\t\tanonymousPresence: ctx.anonymousPresence,\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tconst binding: EditorBinding = {\n\t\t\t\tfragment,\n\t\t\t\tprovider: presenceProvider\n\t\t\t\t\t? { awareness: presenceProvider.awareness, document: subdoc }\n\t\t\t\t\t: { awareness: new Awareness(subdoc), document: subdoc },\n\n\t\t\t\tget pending() {\n\t\t\t\t\treturn prose.isPending(collection, document);\n\t\t\t\t},\n\n\t\t\t\tonPendingChange(callback: (pending: boolean) => void) {\n\t\t\t\t\treturn prose.subscribePending(collection, document, callback);\n\t\t\t\t},\n\n\t\t\t\tdestroy() {\n\t\t\t\t\tpresenceProvider?.destroy();\n\t\t\t\t},\n\t\t\t};\n\n\t\t\treturn binding;\n\t\t},\n\t};\n\n\tconst documentHandles = new Map<string, DocumentHandle<DataType>>();\n\tconst presenceProviders = new Map<string, PresenceProvider>();\n\n\tconst getOrCreateDocumentHandle = (documentId: string): DocumentHandle<DataType> => {\n\t\tlet handle = documentHandles.get(documentId);\n\t\tif (handle) return handle;\n\n\t\tconst ctx = hasContext(collection) ? getContext(collection) : null;\n\t\tif (!ctx) {\n\t\t\tthrow new Error(`Collection ${collection} not initialized. Call init() first.`);\n\t\t}\n\n\t\tconst subdoc = ctx.docManager.getOrCreate(documentId);\n\n\t\tlet presenceProvider = presenceProviders.get(documentId);\n\t\tif (!presenceProvider) {\n\t\t\tconst hasPresenceApi = ctx.api?.session && ctx.api?.presence;\n\t\t\tif (ctx.client && hasPresenceApi && ctx.clientId) {\n\t\t\t\tpresenceProvider = createPresence({\n\t\t\t\t\tconvexClient: ctx.client,\n\t\t\t\t\tapi: {\n\t\t\t\t\t\tpresence: ctx.api.presence!,\n\t\t\t\t\t\tsession: ctx.api.session!,\n\t\t\t\t\t},\n\t\t\t\t\tdocument: documentId,\n\t\t\t\t\tclient: ctx.clientId,\n\t\t\t\t\tydoc: subdoc,\n\t\t\t\t\tsyncReady: ctx.synced,\n\t\t\t\t\tuser: ctx.userGetter,\n\t\t\t\t\tanonymousPresence: ctx.anonymousPresence,\n\t\t\t\t});\n\t\t\t\tpresenceProviders.set(documentId, presenceProvider);\n\t\t\t}\n\t\t}\n\n\t\tconst presence: Presence = presenceProvider ?? {\n\t\t\tjoin: () => {},\n\t\t\tleave: () => {},\n\t\t\tupdate: () => {},\n\t\t\tget: () => ({ local: null, remote: [] }),\n\t\t\tsubscribe: () => () => {},\n\t\t};\n\n\t\thandle = {\n\t\t\tid: documentId,\n\t\t\tpresence,\n\t\t\tawareness: presenceProvider?.awareness ?? new Awareness(subdoc),\n\n\t\t\tasync prose(field: ProseFields<DataType>, options?: ProseOptions): Promise<EditorBinding> {\n\t\t\t\treturn utils.prose(documentId, field, options);\n\t\t\t},\n\t\t};\n\n\t\tdocumentHandles.set(documentId, handle);\n\t\treturn handle;\n\t};\n\n\tlet sessionCache: SessionInfo[] = [];\n\tconst sessionSubscribers = new Set<(sessions: SessionInfo[]) => void>();\n\tlet sessionUnsubscribe: (() => void) | null = null;\n\n\tconst initSessionSubscription = (): void => {\n\t\tif (sessionUnsubscribe) return;\n\n\t\tconst ctx = hasContext(collection) ? getContext(collection) : null;\n\t\tif (!ctx?.client || !ctx?.api?.session) return;\n\n\t\tsessionUnsubscribe = ctx.client.onUpdate(\n\t\t\tctx.api.session,\n\t\t\t{ connected: true },\n\t\t\t(sessions: SessionInfo[]) => {\n\t\t\t\tsessionCache = sessions;\n\t\t\t\tsessionSubscribers.forEach(cb => cb(sessions));\n\t\t\t},\n\t\t);\n\t};\n\n\tconst sessionApi: SessionAPI = {\n\t\tget(docId?: string): SessionInfo[] {\n\t\t\tif (docId) {\n\t\t\t\treturn sessionCache.filter(s => s.document === docId);\n\t\t\t}\n\t\t\treturn sessionCache;\n\t\t},\n\n\t\tsubscribe(callback: (sessions: SessionInfo[]) => void): () => void {\n\t\t\tinitSessionSubscription();\n\t\t\tsessionSubscribers.add(callback);\n\t\t\tcallback(sessionCache);\n\t\t\treturn () => {\n\t\t\t\tsessionSubscribers.delete(callback);\n\t\t\t\tif (sessionSubscribers.size === 0 && sessionUnsubscribe) {\n\t\t\t\t\tsessionUnsubscribe();\n\t\t\t\t\tsessionUnsubscribe = null;\n\t\t\t\t}\n\t\t\t};\n\t\t},\n\t};\n\n\tconst extensions: ConvexCollectionExtensions<DataType> = {\n\t\tdoc(id: string): DocumentHandle<DataType> {\n\t\t\treturn getOrCreateDocumentHandle(id);\n\t\t},\n\t\tsession: sessionApi,\n\t};\n\n\tconst docManager = createDocumentManager(collection);\n\tconst docPersistence: PersistenceProvider = null as any;\n\n\tinitContext({\n\t\tcollection,\n\t\tdocManager,\n\t\tclient: convexClient,\n\t\tapi,\n\t\tpersistence,\n\t\tfields: proseFieldSet,\n\t\tuserGetter,\n\t\tanonymousPresence,\n\t});\n\n\t// Bound replicate operations - set during sync initialization\n\t// Used by onDelete and other handlers that need to sync with TanStack DB\n\tlet ops: BoundReplicateOps<DataType> = null as any;\n\n\t// Create seq service with the persistence KV store\n\tconst seqService = createSeqService(persistence.kv);\n\n\tlet resolvePersistenceReady: (() => void) | undefined;\n\tconst persistenceReadyPromise = new Promise<void>(resolve => {\n\t\tresolvePersistenceReady = resolve;\n\t});\n\n\tlet resolveOptimisticReady: (() => void) | undefined;\n\tconst optimisticReadyPromise = new Promise<void>(resolve => {\n\t\tresolveOptimisticReady = resolve;\n\t});\n\n\tconst recover = async (pushLocal = false): Promise<void> => {\n\t\tconst docIds = docManager.documents();\n\t\tif (docIds.length === 0) return;\n\n\t\tlogger.debug(\"Starting recovery for documents\", { collection, count: docIds.length });\n\n\t\tconst recoveryPromises = docIds.map(async docId => {\n\t\t\ttry {\n\t\t\t\tconst vector = docManager.encodeStateVector(docId);\n\t\t\t\tconst result = await convexClient.query(api.delta, {\n\t\t\t\t\tdocument: docId,\n\t\t\t\t\tvector: vector.buffer as ArrayBuffer,\n\t\t\t\t});\n\n\t\t\t\tif (result.mode === \"recovery\" && result.diff) {\n\t\t\t\t\tconst update = new Uint8Array(result.diff);\n\t\t\t\t\tdocManager.applyUpdate(docId, update, YjsOrigin.Server);\n\t\t\t\t\tlogger.debug(\"Applied server diff during recovery\", { document: docId, collection });\n\t\t\t\t}\n\n\t\t\t\t// Only push local state when explicitly requested (reconnection scenario)\n\t\t\t\t// On init, we only pull server diff - pushing would flood the mutation queue\n\t\t\t\tif (pushLocal) {\n\t\t\t\t\tconst ydoc = docManager.get(docId);\n\t\t\t\t\tif (ydoc) {\n\t\t\t\t\t\tconst localState = Y.encodeStateAsUpdateV2(ydoc);\n\t\t\t\t\t\tconst material = serializeDocument(docManager, docId);\n\n\t\t\t\t\t\tif (material && localState.length > 0) {\n\t\t\t\t\t\t\tawait convexClient.mutation(api.replicate, {\n\t\t\t\t\t\t\t\tdocument: docId,\n\t\t\t\t\t\t\t\tbytes: localState.buffer as ArrayBuffer,\n\t\t\t\t\t\t\t\tmaterial,\n\t\t\t\t\t\t\t\ttype: \"update\",\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tlogger.debug(\"Pushed local changes during recovery\", { document: docId, collection });\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\tlogger.warn(\"Recovery failed for document\", {\n\t\t\t\t\tdocument: docId,\n\t\t\t\t\tcollection,\n\t\t\t\t\terror: error instanceof Error ? error.message : String(error),\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\n\t\tawait Promise.all(recoveryPromises);\n\t\tlogger.debug(\"Recovery completed\", { collection, count: docIds.length });\n\t};\n\n\tconst applyYjsInsert = (mutations: CollectionMutation<DataType>[]): Uint8Array[] => {\n\t\tconst deltas: Uint8Array[] = [];\n\n\t\tfor (const mut of mutations) {\n\t\t\tconst document = String(mut.key);\n\t\t\tconst delta = docManager.transactWithDelta(\n\t\t\t\tdocument,\n\t\t\t\tfieldsMap => {\n\t\t\t\t\tObject.entries(mut.modified as Record<string, unknown>).forEach(([k, v]) => {\n\t\t\t\t\t\tif (proseFieldSet.has(k) && isDoc(v)) {\n\t\t\t\t\t\t\tconst fragment = new Y.XmlFragment();\n\t\t\t\t\t\t\tfieldsMap.set(k, fragment);\n\t\t\t\t\t\t\tfragmentFromJSON(fragment, v);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfieldsMap.set(k, v);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t},\n\t\t\t\tYjsOrigin.Local,\n\t\t\t);\n\t\t\tdeltas.push(delta);\n\t\t}\n\n\t\treturn deltas;\n\t};\n\n\tconst applyYjsUpdate = (mutations: CollectionMutation<DataType>[]): Uint8Array[] => {\n\t\tconst deltas: Uint8Array[] = [];\n\n\t\tfor (const mut of mutations) {\n\t\t\tconst document = String(mut.key);\n\t\t\tconst fieldsMap = docManager.getFields(document);\n\n\t\t\tif (!fieldsMap) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst modifiedFields = mut.modified as Record<string, unknown>;\n\t\t\tif (!modifiedFields) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst delta = docManager.transactWithDelta(\n\t\t\t\tdocument,\n\t\t\t\tfields => {\n\t\t\t\t\tObject.entries(modifiedFields).forEach(([k, v]) => {\n\t\t\t\t\t\tif (proseFieldSet.has(k)) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst existingValue = fields.get(k);\n\t\t\t\t\t\tif (existingValue instanceof Y.XmlFragment) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfields.set(k, v);\n\t\t\t\t\t});\n\t\t\t\t},\n\t\t\t\tYjsOrigin.Local,\n\t\t\t);\n\t\t\tdeltas.push(delta);\n\t\t}\n\n\t\treturn deltas;\n\t};\n\n\tconst applyYjsDelete = (mutations: CollectionMutation<DataType>[]): Uint8Array[] => {\n\t\tconst deltas: Uint8Array[] = [];\n\n\t\tfor (const mut of mutations) {\n\t\t\tconst document = String(mut.key);\n\t\t\tconst ydoc = docManager.get(document);\n\n\t\t\tif (ydoc) {\n\t\t\t\tconst delta = applyDeleteMarkerToDoc(ydoc);\n\t\t\t\tdeltas.push(delta);\n\t\t\t} else {\n\t\t\t\tconst delta = createDeleteDelta();\n\t\t\t\tdeltas.push(delta);\n\t\t\t}\n\t\t}\n\n\t\treturn deltas;\n\t};\n\n\treturn {\n\t\tid: collection,\n\t\tgetKey,\n\t\tutils,\n\t\textensions,\n\n\t\tonInsert: async ({ transaction }: CollectionTransaction<DataType>) => {\n\t\t\tconst deltas = applyYjsInsert(transaction.mutations);\n\n\t\t\ttry {\n\t\t\t\tawait Promise.all([persistenceReadyPromise, optimisticReadyPromise]);\n\n\t\t\t\t// Process mutations in parallel for better performance\n\t\t\t\tawait Promise.all(\n\t\t\t\t\ttransaction.mutations.map(async (mut, i) => {\n\t\t\t\t\t\tconst delta = deltas[i];\n\t\t\t\t\t\tif (!delta || delta.length === 0) return;\n\n\t\t\t\t\t\tconst document = String(mut.key);\n\t\t\t\t\t\tconst materializedDoc = serializeDocument(docManager, document) ?? mut.modified;\n\n\t\t\t\t\t\tawait convexClient.mutation(api.replicate, {\n\t\t\t\t\t\t\tdocument: document,\n\t\t\t\t\t\t\tbytes: delta.buffer,\n\t\t\t\t\t\t\tmaterial: materializedDoc,\n\t\t\t\t\t\t\ttype: \"insert\",\n\t\t\t\t\t\t});\n\t\t\t\t\t}),\n\t\t\t\t);\n\t\t\t} catch (error) {\n\t\t\t\thandleMutationError(error);\n\t\t\t}\n\t\t},\n\n\t\tonUpdate: async ({ transaction }: CollectionTransaction<DataType>) => {\n\t\t\tconst mutation = transaction.mutations[0];\n\t\t\tconst documentKey = String(mutation.key);\n\n\t\t\tconst metadata = mutation.metadata as { contentSync?: ContentSyncMetadata } | undefined;\n\t\t\tconst isContentSync = !!metadata?.contentSync;\n\n\t\t\tconst deltas = isContentSync ? null : applyYjsUpdate(transaction.mutations);\n\n\t\t\ttry {\n\t\t\t\tawait Promise.all([persistenceReadyPromise, optimisticReadyPromise]);\n\n\t\t\t\tif (isContentSync && metadata?.contentSync) {\n\t\t\t\t\tconst { bytes, material } = metadata.contentSync;\n\t\t\t\t\tawait convexClient.mutation(api.replicate, {\n\t\t\t\t\t\tdocument: documentKey,\n\t\t\t\t\t\tbytes,\n\t\t\t\t\t\tmaterial,\n\t\t\t\t\t\ttype: \"update\",\n\t\t\t\t\t});\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (deltas) {\n\t\t\t\t\t// Process mutations in parallel for better performance\n\t\t\t\t\tawait Promise.all(\n\t\t\t\t\t\ttransaction.mutations.map(async (mut, i) => {\n\t\t\t\t\t\t\tconst delta = deltas[i];\n\t\t\t\t\t\t\tif (!delta || delta.length === 0) return;\n\n\t\t\t\t\t\t\tconst docId = String(mut.key);\n\t\t\t\t\t\t\tconst fullDoc = serializeDocument(docManager, docId) ?? mut.modified;\n\n\t\t\t\t\t\t\tawait convexClient.mutation(api.replicate, {\n\t\t\t\t\t\t\t\tdocument: docId,\n\t\t\t\t\t\t\t\tbytes: delta.buffer,\n\t\t\t\t\t\t\t\tmaterial: fullDoc,\n\t\t\t\t\t\t\t\ttype: \"update\",\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}),\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\thandleMutationError(error);\n\t\t\t}\n\t\t},\n\n\t\tonDelete: async ({ transaction }: CollectionTransaction<DataType>) => {\n\t\t\tconst deltas = applyYjsDelete(transaction.mutations);\n\n\t\t\ttry {\n\t\t\t\tawait Promise.all([persistenceReadyPromise, optimisticReadyPromise]);\n\n\t\t\t\tconst itemsToDelete = transaction.mutations\n\t\t\t\t\t.map(mut => mut.original)\n\t\t\t\t\t.filter((item): item is DataType => item !== undefined && Object.keys(item).length > 0);\n\t\t\t\tops.delete(itemsToDelete);\n\n\t\t\t\t// Process mutations in parallel for better performance\n\t\t\t\tawait Promise.all(\n\t\t\t\t\ttransaction.mutations.map(async (mut, i) => {\n\t\t\t\t\t\tconst delta = deltas[i];\n\t\t\t\t\t\tif (!delta || delta.length === 0) return;\n\n\t\t\t\t\t\tawait convexClient.mutation(api.replicate, {\n\t\t\t\t\t\t\tdocument: String(mut.key),\n\t\t\t\t\t\t\tbytes: delta.buffer,\n\t\t\t\t\t\t\ttype: \"delete\",\n\t\t\t\t\t\t});\n\t\t\t\t\t}),\n\t\t\t\t);\n\t\t\t} catch (error) {\n\t\t\t\thandleMutationError(error);\n\t\t\t}\n\t\t},\n\n\t\tsync: {\n\t\t\trowUpdateMode: \"partial\",\n\t\t\tsync: (params: any) => {\n\t\t\t\tconst { markReady, collection: collectionInstance } = params;\n\n\t\t\t\tupdateContext(collection, { ref: collectionInstance });\n\n\t\t\t\tconst ctx = getContext(collection);\n\t\t\t\tif (ctx.cleanup) {\n\t\t\t\t\tctx.cleanup();\n\t\t\t\t\tctx.cleanup = undefined;\n\t\t\t\t}\n\n\t\t\t\tlet subscription: (() => void) | null = null;\n\t\t\t\tconst ssrDocuments = material?.documents;\n\t\t\t\ttype CrdtRecord = Record<string, { bytes: ArrayBuffer; seq: number }>;\n\t\t\t\tconst ssrCrdt = material?.crdt as CrdtRecord | undefined;\n\t\t\t\tconst ssrCursor = material?.cursor;\n\t\t\t\tconst docs: DataType[] = ssrDocuments ? [...ssrDocuments] : [];\n\n\t\t\t\t(async () => {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst existingDocIds = await persistence.listDocuments(collection);\n\t\t\t\t\t\tfor (const docId of existingDocIds) {\n\t\t\t\t\t\t\tdocManager.getOrCreate(docId);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst docPromises = docManager.enablePersistence((document, ydoc) => {\n\t\t\t\t\t\t\treturn persistence.createDocPersistence(`${collection}:${document}`, ydoc);\n\t\t\t\t\t\t});\n\t\t\t\t\t\tawait Promise.all(docPromises);\n\n\t\t\t\t\t\tresolvePersistenceReady?.();\n\n\t\t\t\t\t\tconst clientId = await getClientId(persistence.kv);\n\t\t\t\t\t\tupdateContext(collection, { clientId });\n\n\t\t\t\t\t\tops = createReplicateOps<DataType>(params);\n\t\t\t\t\t\tresolveOptimisticReady?.();\n\n\t\t\t\t\t\tif (ssrCrdt) {\n\t\t\t\t\t\t\tfor (const [docId, state] of Object.entries(ssrCrdt)) {\n\t\t\t\t\t\t\t\tconst update = new Uint8Array(state.bytes);\n\t\t\t\t\t\t\t\tdocManager.applyUpdate(docId, update, YjsOrigin.Server);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tawait recover();\n\n\t\t\t\t\t\tconst docIds = docManager.documents();\n\t\t\t\t\t\tif (docIds.length > 0) {\n\t\t\t\t\t\t\tconst items = extractAllDocuments(docManager) as DataType[];\n\t\t\t\t\t\t\tops.replace(items);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tops.replace([]);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tmarkReady();\n\t\t\t\t\t\tgetContext(collection).resolve?.();\n\n\t\t\t\t\t\tconst persistedCursor = await seqService.load(collection);\n\t\t\t\t\t\tlet cursor = ssrCursor ?? persistedCursor;\n\n\t\t\t\t\t\tif (cursor > 0 && docManager.documents().length === 0) {\n\t\t\t\t\t\t\tcursor = 0;\n\t\t\t\t\t\t\tpersistence.kv.set(`cursor:${collection}`, 0);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Signal that sync is ready (no actor system needed - sync manager is self-contained)\n\t\t\t\t\t\tgetContext(collection).resolveActorReady?.();\n\n\t\t\t\t\t\t// Returns { item, isNew, isDelete } for batching, null if no action needed\n\t\t\t\t\t\ttype ChangeResult = {\n\t\t\t\t\t\t\titem: DataType;\n\t\t\t\t\t\t\tisNew: boolean;\n\t\t\t\t\t\t\tisDelete: boolean;\n\t\t\t\t\t\t} | null;\n\n\t\t\t\t\t\tconst handleSnapshotChange = (\n\t\t\t\t\t\t\tbytes: ArrayBuffer,\n\t\t\t\t\t\t\tdocument: string,\n\t\t\t\t\t\t\texists: boolean,\n\t\t\t\t\t\t): ChangeResult => {\n\t\t\t\t\t\t\tconst hadLocally = docManager.has(document);\n\n\t\t\t\t\t\t\tif (!exists && hadLocally) {\n\t\t\t\t\t\t\t\tconst itemBefore = serializeDocument(docManager, document);\n\t\t\t\t\t\t\t\tdocManager.delete(document);\n\t\t\t\t\t\t\t\tif (itemBefore) {\n\t\t\t\t\t\t\t\t\treturn { item: itemBefore as DataType, isNew: false, isDelete: true };\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (!exists && !hadLocally) {\n\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Apply update - use hadLocally for existence check (avoid double serialization)\n\t\t\t\t\t\t\tconst update = new Uint8Array(bytes);\n\t\t\t\t\t\t\tdocManager.applyUpdate(document, update, YjsOrigin.Server);\n\t\t\t\t\t\t\tconst itemAfter = serializeDocument(docManager, document);\n\n\t\t\t\t\t\t\tif (itemAfter) {\n\t\t\t\t\t\t\t\treturn { item: itemAfter as DataType, isNew: !hadLocally, isDelete: false };\n\t\t\t\t\t\t\t} else if (hadLocally) {\n\t\t\t\t\t\t\t\t// Serialization failed - log warning but don't return item\n\t\t\t\t\t\t\t\tlogger.warn(\"Document serialization returned null after snapshot update\", {\n\t\t\t\t\t\t\t\t\tdocument,\n\t\t\t\t\t\t\t\t\tcollection,\n\t\t\t\t\t\t\t\t\thadFieldsAfter: !!docManager.getFields(document),\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tconst handleDeltaChange = (\n\t\t\t\t\t\t\tbytes: ArrayBuffer,\n\t\t\t\t\t\t\tdocument: string | undefined,\n\t\t\t\t\t\t\texists: boolean,\n\t\t\t\t\t\t): ChangeResult => {\n\t\t\t\t\t\t\tif (!document) {\n\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tconst hadLocally = docManager.has(document);\n\n\t\t\t\t\t\t\tif (!exists && hadLocally) {\n\t\t\t\t\t\t\t\tconst itemBefore = serializeDocument(docManager, document);\n\t\t\t\t\t\t\t\tdocManager.delete(document);\n\t\t\t\t\t\t\t\tif (itemBefore) {\n\t\t\t\t\t\t\t\t\treturn { item: itemBefore as DataType, isNew: false, isDelete: true };\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (!exists && !hadLocally) {\n\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Apply update - use hadLocally for existence check (avoid double serialization)\n\t\t\t\t\t\t\tconst update = new Uint8Array(bytes);\n\t\t\t\t\t\t\tdocManager.applyUpdate(document, update, YjsOrigin.Server);\n\t\t\t\t\t\t\tconst itemAfter = serializeDocument(docManager, document);\n\n\t\t\t\t\t\t\tif (itemAfter) {\n\t\t\t\t\t\t\t\treturn { item: itemAfter as DataType, isNew: !hadLocally, isDelete: false };\n\t\t\t\t\t\t\t} else if (hadLocally) {\n\t\t\t\t\t\t\t\t// Serialization failed - log warning but don't return item\n\t\t\t\t\t\t\t\tlogger.warn(\"Document serialization returned null after delta update\", {\n\t\t\t\t\t\t\t\t\tdocument,\n\t\t\t\t\t\t\t\t\tcollection,\n\t\t\t\t\t\t\t\t\thadFieldsAfter: !!docManager.getFields(document),\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tconst handleSubscriptionUpdate = async (response: any) => {\n\t\t\t\t\t\t\tif (!response || !Array.isArray(response.changes)) {\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tconst { changes, seq: newSeq } = response;\n\t\t\t\t\t\t\tconst syncedDocuments = new Set<string>();\n\n\t\t\t\t\t\t\t// Process all changes and collect results for batching\n\t\t\t\t\t\t\tconst toInsert: DataType[] = [];\n\t\t\t\t\t\t\tconst toUpsert: DataType[] = [];\n\t\t\t\t\t\t\tconst toDelete: DataType[] = [];\n\n\t\t\t\t\t\t\tfor (const change of changes) {\n\t\t\t\t\t\t\t\tconst { type, bytes, document, exists } = change;\n\t\t\t\t\t\t\t\tif (!bytes || !document) {\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tsyncedDocuments.add(document);\n\n\t\t\t\t\t\t\t\tconst result =\n\t\t\t\t\t\t\t\t\ttype === \"snapshot\"\n\t\t\t\t\t\t\t\t\t\t? handleSnapshotChange(bytes, document, exists ?? true)\n\t\t\t\t\t\t\t\t\t\t: handleDeltaChange(bytes, document, exists ?? true);\n\n\t\t\t\t\t\t\t\tif (result) {\n\t\t\t\t\t\t\t\t\tif (result.isDelete) {\n\t\t\t\t\t\t\t\t\t\ttoDelete.push(result.item);\n\t\t\t\t\t\t\t\t\t} else if (result.isNew) {\n\t\t\t\t\t\t\t\t\t\ttoInsert.push(result.item);\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\ttoUpsert.push(result.item);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Batch ops calls - single transaction instead of N separate calls\n\t\t\t\t\t\t\tif (toDelete.length > 0) ops.delete(toDelete);\n\t\t\t\t\t\t\tif (toInsert.length > 0) ops.insert(toInsert);\n\t\t\t\t\t\t\tif (toUpsert.length > 0) ops.upsert(toUpsert);\n\n\t\t\t\t\t\t\tif (newSeq !== undefined) {\n\t\t\t\t\t\t\t\tpersistence.kv.set(`cursor:${collection}`, newSeq);\n\n\t\t\t\t\t\t\t\t// Mark presence for synced documents - fire and forget but log errors\n\t\t\t\t\t\t\t\t// Using void to explicitly acknowledge this is intentionally not awaited\n\t\t\t\t\t\t\t\t// as presence marking is non-critical background work\n\t\t\t\t\t\t\t\tconst markPromises = Array.from(syncedDocuments).map(document => {\n\t\t\t\t\t\t\t\t\tconst vector = docManager.encodeStateVector(document);\n\t\t\t\t\t\t\t\t\treturn convexClient\n\t\t\t\t\t\t\t\t\t\t.mutation(api.presence, {\n\t\t\t\t\t\t\t\t\t\t\tdocument,\n\t\t\t\t\t\t\t\t\t\t\tclient: clientId,\n\t\t\t\t\t\t\t\t\t\t\taction: \"mark\",\n\t\t\t\t\t\t\t\t\t\t\tseq: newSeq,\n\t\t\t\t\t\t\t\t\t\t\tvector: vector.buffer as ArrayBuffer,\n\t\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t\t\t.catch((error: Error) => {\n\t\t\t\t\t\t\t\t\t\t\tlogger.warn(\"Failed to mark presence\", {\n\t\t\t\t\t\t\t\t\t\t\t\tdocument,\n\t\t\t\t\t\t\t\t\t\t\t\tcollection,\n\t\t\t\t\t\t\t\t\t\t\t\terror: error.message,\n\t\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\tvoid Promise.all(markPromises);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tsubscription = convexClient.onUpdate(\n\t\t\t\t\t\t\tapi.delta,\n\t\t\t\t\t\t\t{ seq: cursor, limit: 1000 },\n\t\t\t\t\t\t\t(response: any) => {\n\t\t\t\t\t\t\t\thandleSubscriptionUpdate(response);\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\t// Reconnection handling: when browser comes back online, resync local state\n\t\t\t\t\t\tif (typeof globalThis.window !== \"undefined\") {\n\t\t\t\t\t\t\tlet wasOffline = false;\n\t\t\t\t\t\t\tconst handleOffline = () => {\n\t\t\t\t\t\t\t\twasOffline = true;\n\t\t\t\t\t\t\t\tlogger.debug(\"Network offline detected\", { collection });\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tconst handleOnline = () => {\n\t\t\t\t\t\t\t\tif (wasOffline) {\n\t\t\t\t\t\t\t\t\tlogger.info(\"Network online restored, running recovery sync\", { collection });\n\t\t\t\t\t\t\t\t\twasOffline = false;\n\t\t\t\t\t\t\t\t\trecover(true).catch((error: Error) => {\n\t\t\t\t\t\t\t\t\t\tlogger.warn(\"Recovery sync failed after reconnection\", {\n\t\t\t\t\t\t\t\t\t\t\tcollection,\n\t\t\t\t\t\t\t\t\t\t\terror: error.message,\n\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\tglobalThis.window.addEventListener(\"offline\", handleOffline);\n\t\t\t\t\t\t\tglobalThis.window.addEventListener(\"online\", handleOnline);\n\n\t\t\t\t\t\t\t// Store cleanup function in context for proper cleanup\n\t\t\t\t\t\t\tconst ctx = getContext(collection);\n\t\t\t\t\t\t\t(ctx as any).cleanupReconnection = () => {\n\t\t\t\t\t\t\t\tglobalThis.window.removeEventListener(\"offline\", handleOffline);\n\t\t\t\t\t\t\t\tglobalThis.window.removeEventListener(\"online\", handleOnline);\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Note: markReady() was already called above (local-first)\n\t\t\t\t\t\t// Subscription is background replication, not blocking\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\t// Log error before marking ready to aid debugging sync failures\n\t\t\t\t\t\tlogger.error(\"Sync initialization failed\", {\n\t\t\t\t\t\t\tcollection,\n\t\t\t\t\t\t\terror: error instanceof Error ? error.message : String(error),\n\t\t\t\t\t\t\tstack: error instanceof Error ? error.stack : undefined,\n\t\t\t\t\t\t});\n\t\t\t\t\t\tmarkReady();\n\t\t\t\t\t}\n\t\t\t\t})();\n\n\t\t\t\treturn {\n\t\t\t\t\tmaterial: docs,\n\t\t\t\t\tcleanup: () => {\n\t\t\t\t\t\t// Clean up reconnection listeners if stored in context\n\t\t\t\t\t\tif (hasContext(collection)) {\n\t\t\t\t\t\t\tconst ctx = getContext(collection);\n\t\t\t\t\t\t\t(ctx as any).cleanupReconnection?.();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsubscription?.();\n\t\t\t\t\t\tprose.cleanup(collection);\n\t\t\t\t\t\tdeleteContext(collection);\n\t\t\t\t\t\tdocPersistence?.destroy();\n\t\t\t\t\t\tdocManager?.destroy();\n\t\t\t\t\t},\n\t\t\t\t};\n\t\t\t},\n\t\t},\n\t};\n}\n\ntype LazyCollectionConfig<T extends object> = Omit<\n\tConvexCollectionConfig<T>,\n\t\"persistence\" | \"material\" | \"validator\"\n>;\n\nexport interface LazyCollection<T extends object> {\n\tinit(material?: Materialized<T> | PaginatedMaterial<T>): Promise<void>;\n\tget(): Collection<T, string, ConvexCollectionUtils<T>, never, T> &\n\t\tNonSingleResult &\n\t\tConvexCollectionExtensions<T>;\n\treadonly $docType?: T;\n\treadonly pagination: {\n\t\tload(): Promise<PaginatedPage<T> | null>;\n\t\treadonly status: PaginationStatus;\n\t\treadonly canLoadMore: boolean;\n\t\treadonly count: number;\n\t\tsubscribe(callback: (state: PaginationState) => void): () => void;\n\t};\n}\n\nexport type ConvexCollection<T extends object> = Collection<\n\tT,\n\tany,\n\tConvexCollectionUtils<T>,\n\tnever,\n\tT\n> &\n\tNonSingleResult &\n\tConvexCollectionExtensions<T>;\n\n/** Options for collection.create() */\nexport interface CreateCollectionOptions<T extends object> {\n\tschema: VersionedSchema<GenericValidator>;\n\tpersistence: () => Promise<Persistence>;\n\tconfig: () => {\n\t\tconvexClient: ConvexClient;\n\t\tapi: ConvexCollectionApi;\n\t\tgetKey: (doc: T) => string;\n\t\tuser?: () => UserIdentity | undefined;\n\t};\n\tclientMigrations?: ClientMigrationMap;\n\tonMigrationError?: MigrationErrorHandler;\n\tpagination?: PaginationConfig;\n}\n\n/**\n * Create a collection with versioned schema support.\n * Handles automatic client-side migrations when schema version changes.\n */\nfunction createVersionedCollection<T extends object>(\n\toptions: CreateCollectionOptions<T>,\n): LazyCollection<T> {\n\tconst { schema: versionedSchema, clientMigrations, onMigrationError } = options;\n\n\tlet persistence: Persistence | null = null;\n\tlet resolvedConfig: LazyCollectionConfig<T> | null = null;\n\tlet material: Materialized<T> | undefined;\n\ttype Instance = LazyCollection<T>[\"get\"] extends () => infer R ? R : never;\n\tlet instance: Instance | null = null;\n\tlet collectionName: string | null = null;\n\n\tlet paginationState: PaginationState = {\n\t\tstatus: \"idle\",\n\t\tcount: 0,\n\t\tcursor: null,\n\t};\n\tconst listeners = new Set<(state: PaginationState) => void>();\n\n\tconst isPaginatedMaterial = (\n\t\tmat: Materialized<T> | PaginatedMaterial<T> | undefined,\n\t): mat is PaginatedMaterial<T> => {\n\t\treturn mat !== undefined && \"pages\" in mat && Array.isArray(mat.pages);\n\t};\n\n\tconst convertPaginatedToMaterial = (paginated: PaginatedMaterial<T>): Materialized<T> => {\n\t\tconst allDocs = paginated.pages.flatMap(p => p.page);\n\t\treturn {\n\t\t\tdocuments: allDocs,\n\t\t\tcount: allDocs.length,\n\t\t};\n\t};\n\n\treturn {\n\t\tasync init(mat?: Materialized<T> | PaginatedMaterial<T>) {\n\t\t\tif (!persistence) {\n\t\t\t\tpersistence = await options.persistence();\n\t\t\t\tconst userConfig = options.config();\n\n\t\t\t\t// Extract collection name from api.delta function path\n\t\t\t\tconst functionPath = getFunctionName(userConfig.api.delta);\n\t\t\t\tcollectionName = functionPath.split(\":\")[0] ?? \"unknown\";\n\n\t\t\t\t// Convert versioned config to legacy config format\n\t\t\t\tresolvedConfig = {\n\t\t\t\t\tconvexClient: userConfig.convexClient,\n\t\t\t\t\tapi: userConfig.api,\n\t\t\t\t\tgetKey: userConfig.getKey,\n\t\t\t\t\tuser: userConfig.user,\n\t\t\t\t} as LazyCollectionConfig<T>;\n\n\t\t\t\tif (isPaginatedMaterial(mat)) {\n\t\t\t\t\tmaterial = convertPaginatedToMaterial(mat);\n\t\t\t\t\tpaginationState = {\n\t\t\t\t\t\tstatus: mat.isDone ? \"done\" : \"idle\",\n\t\t\t\t\t\tcount: mat.pages.reduce((sum, p) => sum + p.page.length, 0),\n\t\t\t\t\t\tcursor: mat.cursor,\n\t\t\t\t\t};\n\t\t\t\t} else {\n\t\t\t\t\tmaterial = mat;\n\t\t\t\t}\n\n\t\t\t\t// Run migrations if SQLite persistence is available\n\t\t\t\tif (persistence.db && collectionName) {\n\t\t\t\t\tawait runMigrations({\n\t\t\t\t\t\tcollection: collectionName,\n\t\t\t\t\t\tschema: versionedSchema,\n\t\t\t\t\t\tdb: persistence.db,\n\t\t\t\t\t\tclientMigrations,\n\t\t\t\t\t\tonError: onMigrationError,\n\t\t\t\t\t\tlistDocuments: async () => persistence!.listDocuments(collectionName!),\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\tget() {\n\t\t\tif (!persistence || !resolvedConfig) {\n\t\t\t\tthrow new Error(\"Call init() before get()\");\n\t\t\t}\n\t\t\tif (!instance) {\n\t\t\t\tconst opts = convexCollectionOptions<T>({\n\t\t\t\t\t...resolvedConfig,\n\t\t\t\t\tvalidator: versionedSchema.shape,\n\t\t\t\t\tpersistence,\n\t\t\t\t\tmaterial,\n\t\t\t\t});\n\t\t\t\tconst baseCollection = createCollection(opts);\n\t\t\t\tinstance = Object.assign(baseCollection, opts.extensions) as Instance;\n\t\t\t}\n\t\t\treturn instance!;\n\t\t},\n\n\t\tpagination: {\n\t\t\tasync load(): Promise<PaginatedPage<T> | null> {\n\t\t\t\tif (!persistence || !resolvedConfig) {\n\t\t\t\t\tthrow new Error(\"Call init() before pagination.load()\");\n\t\t\t\t}\n\t\t\t\tif (paginationState.status === \"done\") {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\t// TODO: Implement pagination for versioned collections\n\t\t\t\treturn null;\n\t\t\t},\n\t\t\tget status() {\n\t\t\t\treturn paginationState.status;\n\t\t\t},\n\t\t\tget canLoadMore() {\n\t\t\t\treturn paginationState.status !== \"done\" && paginationState.status !== \"busy\";\n\t\t\t},\n\t\t\tget count() {\n\t\t\t\treturn paginationState.count;\n\t\t\t},\n\t\t\tsubscribe(callback: (state: PaginationState) => void) {\n\t\t\t\tlisteners.add(callback);\n\t\t\t\treturn () => listeners.delete(callback);\n\t\t\t},\n\t\t},\n\t};\n}\n\nexport namespace collection {\n\texport type Infer<C> = C extends { $docType?: infer T } ? NonNullable<T> : never;\n}\n\n/**\n * Create a collection with versioned schema (new API).\n *\n * @example\n * ```typescript\n * const tasks = collection.create({\n *   schema: taskSchema,\n *   persistence: () => persistence.web.sqlite.create(),\n *   config: () => ({\n *     convexClient: new ConvexClient(url),\n *     api: api.tasks,\n *     getKey: (t) => t.id,\n *   }),\n *   onMigrationError: async (error, ctx) => {\n *     if (ctx.canResetSafely) return { action: \"reset\" };\n *     return { action: \"keep-old-schema\" };\n *   },\n * });\n * ```\n */\nexport const collection = {\n\tcreate: createVersionedCollection,\n};\n","import { getStableAnonColor, getStableAnonName } from \"$/client/services/presence\";\n\n/**\n * User identity for presence and collaborative features.\n */\nexport interface UserIdentity {\n\tid?: string;\n\tname?: string;\n\tcolor?: string;\n\tavatar?: string;\n}\n\n/**\n * Configuration for anonymous presence names and colors.\n * Allows applications to customize the adjectives, nouns, and colors\n * used when generating anonymous user identities.\n */\nexport interface AnonymousPresenceConfig {\n\t/** List of adjectives for anonymous names (e.g., [\"Swift\", \"Bright\", \"Calm\"]) */\n\tadjectives?: string[];\n\t/** List of nouns for anonymous names (e.g., [\"Fox\", \"Owl\", \"Bear\"]) */\n\tnouns?: string[];\n\t/** List of hex colors for anonymous users (e.g., [\"#9F5944\", \"#A9704D\"]) */\n\tcolors?: string[];\n}\n\n/**\n * Identity namespace for creating user identities and generating stable anonymous identifiers.\n *\n * @example\n * ```typescript\n * import { identity } from \"@trestleinc/replicate/client\";\n *\n * // Create from your auth provider\n * const user = identity.from({\n *   id: authSession.user.id,\n *   name: authSession.user.name,\n *   avatar: authSession.user.image,\n *   color: identity.color.generate(authSession.user.id),\n * });\n *\n * // Generate stable anonymous identifiers\n * identity.color.generate(\"seed-123\")    // Deterministic color\n * identity.name.anonymous(\"seed-123\")    // \"Swift Fox\", \"Calm Bear\", etc.\n * ```\n */\nexport const identity = {\n\t/**\n\t * Create a user identity from auth provider data.\n\t * Pass-through helper that ensures type safety.\n\t */\n\tfrom(user: UserIdentity): UserIdentity {\n\t\treturn { ...user };\n\t},\n\n\t/**\n\t * Color utilities for generating stable, deterministic colors.\n\t */\n\tcolor: {\n\t\t/**\n\t\t * Generate a deterministic color from any seed string.\n\t\t * Same seed always produces the same color.\n\t\t *\n\t\t * @param seed - Any string (user ID, client ID, etc.)\n\t\t * @param config - Optional custom colors configuration\n\t\t * @returns Hex color string (e.g., \"#9F5944\")\n\t\t */\n\t\tgenerate(seed: string, config?: AnonymousPresenceConfig): string {\n\t\t\treturn getStableAnonColor(seed, config);\n\t\t},\n\t},\n\n\t/**\n\t * Name utilities for generating stable anonymous names.\n\t */\n\tname: {\n\t\t/**\n\t\t * Generate a stable anonymous name from any seed string.\n\t\t * Same seed always produces the same name.\n\t\t *\n\t\t * @param seed - Any string (user ID, client ID, etc.)\n\t\t * @param config - Optional custom adjectives/nouns configuration\n\t\t * @returns Anonymous name (e.g., \"Swift Fox\", \"Calm Bear\")\n\t\t */\n\t\tanonymous(seed: string, config?: AnonymousPresenceConfig): string {\n\t\t\treturn getStableAnonName(seed, config);\n\t\t},\n\t},\n} as const;\n","/**\n * In-memory persistence implementation for testing.\n *\n * State is not persisted across sessions - useful for tests and development.\n */\nimport type * as Y from \"yjs\";\nimport type { Persistence, PersistenceProvider, KeyValueStore } from \"./types.js\";\n\n/**\n * In-memory key-value store.\n */\nclass MemoryKeyValueStore implements KeyValueStore {\n\tprivate store = new Map<string, unknown>();\n\n\tasync get<T>(key: string): Promise<T | undefined> {\n\t\treturn this.store.get(key) as T | undefined;\n\t}\n\n\tasync set<T>(key: string, value: T): Promise<void> {\n\t\tthis.store.set(key, value);\n\t}\n\n\tasync del(key: string): Promise<void> {\n\t\tthis.store.delete(key);\n\t}\n}\n\n/**\n * No-op persistence provider for in-memory usage.\n *\n * The Y.Doc is kept in memory without persistence.\n */\nclass MemoryPersistenceProvider implements PersistenceProvider {\n\treadonly whenSynced = Promise.resolve();\n\n\tdestroy(): void {\n\t\t// No resources to clean up\n\t}\n}\n\n/**\n * Create an in-memory persistence factory.\n *\n * Useful for testing where you don't want IndexedDB side effects.\n *\n * @example\n * ```typescript\n * // In tests\n * convexCollectionOptions<Task>({\n *   // ... other options\n *   persistence: memoryPersistence(),\n * });\n * ```\n */\nexport function memoryPersistence(): Persistence {\n\tconst kv = new MemoryKeyValueStore();\n\treturn {\n\t\tcreateDocPersistence: (_: string, __: Y.Doc) => new MemoryPersistenceProvider(),\n\t\tasync listDocuments(_prefix: string): Promise<string[]> {\n\t\t\treturn [];\n\t\t},\n\t\tkv,\n\t};\n}\n","import * as Y from \"yjs\";\nimport type {\n\tPersistence,\n\tPersistenceProvider,\n\tKeyValueStore,\n\tMigrationDatabase,\n} from \"../types.js\";\n\nexport interface Executor {\n\texecute(sql: string, params?: unknown[]): Promise<{ rows: Record<string, unknown>[] }>;\n\tclose(): void;\n}\n\nexport async function initSchema(executor: Executor): Promise<void> {\n\tawait executor.execute(`\n    CREATE TABLE IF NOT EXISTS snapshots (\n      collection TEXT PRIMARY KEY,\n      data BLOB NOT NULL,\n      state_vector BLOB,\n      seq INTEGER DEFAULT 0\n    )\n  `);\n\n\tawait executor.execute(`\n    CREATE TABLE IF NOT EXISTS deltas (\n      id INTEGER PRIMARY KEY AUTOINCREMENT,\n      collection TEXT NOT NULL,\n      data BLOB NOT NULL\n    )\n  `);\n\n\tawait executor.execute(`\n    CREATE INDEX IF NOT EXISTS deltas_collection_idx ON deltas (collection)\n  `);\n\n\tawait executor.execute(`\n    CREATE TABLE IF NOT EXISTS kv (\n      key TEXT PRIMARY KEY,\n      value TEXT NOT NULL\n    )\n  `);\n}\n\nclass SqliteKeyValueStore implements KeyValueStore {\n\tconstructor(private executor: Executor) {}\n\n\tasync get<T>(key: string): Promise<T | undefined> {\n\t\tconst result = await this.executor.execute(\"SELECT value FROM kv WHERE key = ?\", [key]);\n\t\tif (result.rows.length === 0) return undefined;\n\t\treturn JSON.parse(result.rows[0].value as string) as T;\n\t}\n\n\tasync set<T>(key: string, value: T): Promise<void> {\n\t\tawait this.executor.execute(\"INSERT OR REPLACE INTO kv (key, value) VALUES (?, ?)\", [\n\t\t\tkey,\n\t\t\tJSON.stringify(value),\n\t\t]);\n\t}\n\n\tasync del(key: string): Promise<void> {\n\t\tawait this.executor.execute(\"DELETE FROM kv WHERE key = ?\", [key]);\n\t}\n}\n\n/**\n * Adapter that wraps Executor to provide MigrationDatabase interface.\n */\nclass SqliteMigrationDatabase implements MigrationDatabase {\n\tconstructor(private executor: Executor) {}\n\n\tasync run(sql: string, params?: unknown[]): Promise<void> {\n\t\tawait this.executor.execute(sql, params);\n\t}\n\n\tasync exec(sql: string): Promise<void> {\n\t\tawait this.executor.execute(sql);\n\t}\n\n\tasync get<T>(sql: string, params?: unknown[]): Promise<T | undefined> {\n\t\tconst result = await this.executor.execute(sql, params);\n\t\tif (result.rows.length === 0) return undefined;\n\t\treturn result.rows[0] as T;\n\t}\n\n\tasync all<T>(sql: string, params?: unknown[]): Promise<T[]> {\n\t\tconst result = await this.executor.execute(sql, params);\n\t\treturn result.rows as T[];\n\t}\n}\n\nclass SqlitePersistenceProvider implements PersistenceProvider {\n\tprivate updateHandler: (update: Uint8Array, origin: unknown) => void;\n\tprivate pendingWrites: Promise<void>[] = [];\n\tprivate lastError: Error | null = null;\n\treadonly whenSynced: Promise<void>;\n\n\tconstructor(\n\t\tprivate executor: Executor,\n\t\tprivate collection: string,\n\t\tprivate ydoc: Y.Doc,\n\t\tprivate onError?: (error: Error) => void,\n\t) {\n\t\tthis.whenSynced = this.loadState();\n\n\t\tthis.updateHandler = (update: Uint8Array, origin: unknown) => {\n\t\t\tif (origin !== \"sqlite\") {\n\t\t\t\tconst writePromise = this.saveUpdate(update).catch((error: Error) => {\n\t\t\t\t\tthis.lastError = error;\n\t\t\t\t\tthis.onError?.(error);\n\t\t\t\t});\n\t\t\t\tthis.pendingWrites.push(writePromise);\n\t\t\t\twritePromise.finally(() => {\n\t\t\t\t\tthis.pendingWrites = this.pendingWrites.filter(p => p !== writePromise);\n\t\t\t\t});\n\t\t\t}\n\t\t};\n\t\tthis.ydoc.on(\"update\", this.updateHandler);\n\t}\n\n\tasync flush(): Promise<void> {\n\t\tawait Promise.all(this.pendingWrites);\n\t\tif (this.lastError) {\n\t\t\tconst error = this.lastError;\n\t\t\tthis.lastError = null;\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\tprivate async loadState(): Promise<void> {\n\t\tconst snapshotResult = await this.executor.execute(\n\t\t\t\"SELECT data FROM snapshots WHERE collection = ?\",\n\t\t\t[this.collection],\n\t\t);\n\n\t\tif (snapshotResult.rows.length > 0) {\n\t\t\tconst raw = snapshotResult.rows[0].data;\n\t\t\tconst snapshotData = raw instanceof Uint8Array ? raw : new Uint8Array(raw as ArrayBuffer);\n\t\t\tY.applyUpdate(this.ydoc, snapshotData, \"sqlite\");\n\t\t}\n\n\t\tconst deltasResult = await this.executor.execute(\n\t\t\t\"SELECT data FROM deltas WHERE collection = ? ORDER BY id ASC\",\n\t\t\t[this.collection],\n\t\t);\n\n\t\tfor (const row of deltasResult.rows) {\n\t\t\tconst raw = row.data;\n\t\t\tconst updateData = raw instanceof Uint8Array ? raw : new Uint8Array(raw as ArrayBuffer);\n\t\t\tY.applyUpdate(this.ydoc, updateData, \"sqlite\");\n\t\t}\n\t}\n\n\tprivate async saveUpdate(update: Uint8Array): Promise<void> {\n\t\tawait this.executor.execute(\"INSERT INTO deltas (collection, data) VALUES (?, ?)\", [\n\t\t\tthis.collection,\n\t\t\tupdate,\n\t\t]);\n\t}\n\n\tdestroy(): void {\n\t\tthis.ydoc.off(\"update\", this.updateHandler);\n\t}\n}\n\nexport function createPersistenceFromExecutor(executor: Executor): Persistence {\n\treturn {\n\t\tcreateDocPersistence: (collection: string, ydoc: Y.Doc) =>\n\t\t\tnew SqlitePersistenceProvider(executor, collection, ydoc),\n\t\tasync listDocuments(prefix: string): Promise<string[]> {\n\t\t\tconst result = await executor.execute(\n\t\t\t\t`SELECT DISTINCT collection FROM (\n          SELECT collection FROM snapshots WHERE collection LIKE ?\n          UNION\n          SELECT collection FROM deltas WHERE collection LIKE ?\n        )`,\n\t\t\t\t[`${prefix}:%`, `${prefix}:%`],\n\t\t\t);\n\t\t\treturn result.rows.map(row => {\n\t\t\t\tconst collection = row.collection as string;\n\t\t\t\tconst parts = collection.split(\":\");\n\t\t\t\treturn parts.slice(1).join(\":\");\n\t\t\t});\n\t\t},\n\t\tkv: new SqliteKeyValueStore(executor),\n\t\tdb: new SqliteMigrationDatabase(executor),\n\t};\n}\n","import { initSchema, createPersistenceFromExecutor, type Executor } from \"./schema.js\";\nimport type { Persistence } from \"../types.js\";\n\ninterface OPSQLiteDatabase {\n\texecute(sql: string, params?: unknown[]): Promise<{ rows: Record<string, unknown>[] }>;\n\tclose(): void;\n}\n\nclass OPSqliteExecutor implements Executor {\n\tconstructor(private db: OPSQLiteDatabase) {}\n\n\tasync execute(sql: string, params?: unknown[]): Promise<{ rows: Record<string, unknown>[] }> {\n\t\tconst result = await this.db.execute(sql, params);\n\t\treturn { rows: result.rows || [] };\n\t}\n\n\tclose(): void {\n\t\tthis.db.close();\n\t}\n}\n\nexport async function createNativeSqlitePersistence(\n\tdb: OPSQLiteDatabase,\n\t_dbName: string,\n): Promise<Persistence> {\n\tconst executor = new OPSqliteExecutor(db);\n\tawait initSchema(executor);\n\treturn createPersistenceFromExecutor(executor);\n}\n","import { createPersistenceFromExecutor, type Executor } from \"./schema.js\";\nimport type { Persistence } from \"../types.js\";\n\nconst INIT = 0;\nconst EXECUTE = 1;\nconst CLOSE = 2;\n\ninterface Request {\n\tid: number;\n\ttype: number;\n\tname?: string;\n\tsql?: string;\n\tparams?: unknown[];\n}\n\ninterface Response {\n\tid: number;\n\tok: boolean;\n\trows?: Record<string, unknown>[];\n\terror?: string;\n}\n\ntype PendingRequest = {\n\tresolve: (rows: Record<string, unknown>[]) => void;\n\treject: (error: Error) => void;\n};\n\nclass WorkerExecutor implements Executor {\n\tprivate worker: Worker;\n\tprivate nextId = 0;\n\tprivate pending = new Map<number, PendingRequest>();\n\tprivate terminated = false;\n\n\tconstructor(worker: Worker) {\n\t\tthis.worker = worker;\n\t\tthis.worker.onmessage = (e: MessageEvent<Response>) => {\n\t\t\tconst { id, ok, rows, error } = e.data;\n\t\t\tconst handler = this.pending.get(id);\n\t\t\tif (!handler) return;\n\t\t\tthis.pending.delete(id);\n\n\t\t\tif (ok) {\n\t\t\t\thandler.resolve(rows ?? []);\n\t\t\t} else {\n\t\t\t\thandler.reject(new Error(error ?? \"Unknown worker error\"));\n\t\t\t}\n\t\t};\n\n\t\t// Handle worker errors - reject all pending requests\n\t\tthis.worker.onerror = (event: ErrorEvent) => {\n\t\t\tconst error = new Error(`Worker error: ${event.message || \"Unknown error\"}`);\n\t\t\tthis.rejectAllPending(error);\n\t\t};\n\n\t\t// Handle worker message errors\n\t\tthis.worker.onmessageerror = () => {\n\t\t\tconst error = new Error(\"Worker message deserialization failed\");\n\t\t\tthis.rejectAllPending(error);\n\t\t};\n\t}\n\n\tprivate rejectAllPending(error: Error): void {\n\t\tthis.terminated = true;\n\t\tfor (const [, handler] of this.pending) {\n\t\t\thandler.reject(error);\n\t\t}\n\t\tthis.pending.clear();\n\t}\n\n\tprivate send(type: number, payload: Partial<Request> = {}): Promise<Record<string, unknown>[]> {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tif (this.terminated) {\n\t\t\t\treject(new Error(\"Worker has been terminated\"));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst id = this.nextId++;\n\t\t\tthis.pending.set(id, { resolve, reject });\n\t\t\tthis.worker.postMessage({ id, type, ...payload } satisfies Request);\n\t\t});\n\t}\n\n\tasync init(name: string): Promise<void> {\n\t\tawait this.send(INIT, { name });\n\t}\n\n\tasync execute(sql: string, params?: unknown[]): Promise<{ rows: Record<string, unknown>[] }> {\n\t\tconst rows = await this.send(EXECUTE, { sql, params });\n\t\treturn { rows };\n\t}\n\n\tclose(): void {\n\t\tfor (const [, handler] of this.pending) {\n\t\t\thandler.reject(new Error(\"Worker terminated\"));\n\t\t}\n\t\tthis.pending.clear();\n\t\tthis.send(CLOSE).catch(() => {});\n\t\tthis.worker.terminate();\n\t}\n}\n\nexport interface WebSqliteOptions {\n\tname: string;\n\tworker: Worker | (() => Worker | Promise<Worker>);\n}\n\nexport async function createWebSqlitePersistence(options: WebSqliteOptions): Promise<Persistence> {\n\tconst { name, worker } = options;\n\n\tconst resolvedWorker = typeof worker === \"function\" ? await worker() : worker;\n\tconst executor = new WorkerExecutor(resolvedWorker);\n\n\ttry {\n\t\tawait executor.init(name);\n\t} catch (error) {\n\t\tresolvedWorker.terminate();\n\t\tthrow new Error(`Failed to initialize: ${error}`);\n\t}\n\n\treturn createPersistenceFromExecutor(executor);\n}\n\nexport function onceWebSqlitePersistence(options: WebSqliteOptions): () => Promise<Persistence> {\n\tlet instance: Promise<Persistence> | null = null;\n\treturn () => (instance ??= createWebSqlitePersistence(options));\n}\n","import * as Y from \"yjs\";\nimport type { StorageAdapter, Persistence, PersistenceProvider, KeyValueStore } from \"./types.js\";\n\nconst SNAPSHOT_PREFIX = \"snapshot:\";\nconst UPDATE_PREFIX = \"update:\";\nconst META_PREFIX = \"meta:\";\n\nclass AdapterKeyValueStore implements KeyValueStore {\n\tconstructor(private adapter: StorageAdapter) {}\n\n\tasync get<T>(key: string): Promise<T | undefined> {\n\t\tconst data = await this.adapter.get(`${META_PREFIX}${key}`);\n\t\tif (!data) return undefined;\n\t\treturn JSON.parse(new TextDecoder().decode(data)) as T;\n\t}\n\n\tasync set<T>(key: string, value: T): Promise<void> {\n\t\tawait this.adapter.set(`${META_PREFIX}${key}`, new TextEncoder().encode(JSON.stringify(value)));\n\t}\n\n\tasync del(key: string): Promise<void> {\n\t\tawait this.adapter.delete(`${META_PREFIX}${key}`);\n\t}\n}\n\nclass AdapterPersistenceProvider implements PersistenceProvider {\n\tprivate updateHandler: (update: Uint8Array, origin: unknown) => void;\n\tprivate updateCounter = 0;\n\treadonly whenSynced: Promise<void>;\n\n\tconstructor(\n\t\tprivate adapter: StorageAdapter,\n\t\tprivate collection: string,\n\t\tprivate ydoc: Y.Doc,\n\t) {\n\t\tthis.whenSynced = this.loadState();\n\n\t\tthis.updateHandler = (update: Uint8Array, origin: unknown) => {\n\t\t\tif (origin !== \"custom\") {\n\t\t\t\tvoid this.saveUpdate(update);\n\t\t\t}\n\t\t};\n\t\tthis.ydoc.on(\"update\", this.updateHandler);\n\t}\n\n\tprivate async loadState(): Promise<void> {\n\t\tconst snapshotData = await this.adapter.get(`${SNAPSHOT_PREFIX}${this.collection}`);\n\t\tif (snapshotData) {\n\t\t\tY.applyUpdate(this.ydoc, snapshotData, \"custom\");\n\t\t}\n\n\t\tconst updateKeys = await this.adapter.keys(`${UPDATE_PREFIX}${this.collection}:`);\n\t\tconst sortedKeys = updateKeys.sort();\n\n\t\tfor (const key of sortedKeys) {\n\t\t\tconst updateData = await this.adapter.get(key);\n\t\t\tif (updateData) {\n\t\t\t\tY.applyUpdate(this.ydoc, updateData, \"custom\");\n\t\t\t\tconst seq = parseInt(key.split(\":\").pop() || \"0\", 10);\n\t\t\t\tif (seq > this.updateCounter) {\n\t\t\t\t\tthis.updateCounter = seq;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate async saveUpdate(update: Uint8Array): Promise<void> {\n\t\tthis.updateCounter++;\n\t\tconst paddedCounter = String(this.updateCounter).padStart(10, \"0\");\n\t\tawait this.adapter.set(`${UPDATE_PREFIX}${this.collection}:${paddedCounter}`, update);\n\t}\n\n\tdestroy(): void {\n\t\tthis.ydoc.off(\"update\", this.updateHandler);\n\t}\n}\n\nexport function createCustomPersistence(adapter: StorageAdapter): Persistence {\n\treturn {\n\t\tcreateDocPersistence: (collection: string, ydoc: Y.Doc) =>\n\t\t\tnew AdapterPersistenceProvider(adapter, collection, ydoc),\n\t\tasync listDocuments(prefix: string): Promise<string[]> {\n\t\t\tconst snapshotKeys = await adapter.keys(`${SNAPSHOT_PREFIX}${prefix}:`);\n\t\t\tconst updateKeys = await adapter.keys(`${UPDATE_PREFIX}${prefix}:`);\n\n\t\t\tconst docIds = new Set<string>();\n\n\t\t\tfor (const key of snapshotKeys) {\n\t\t\t\tconst withoutPrefix = key.slice(SNAPSHOT_PREFIX.length);\n\t\t\t\tconst parts = withoutPrefix.split(\":\");\n\t\t\t\tdocIds.add(parts.slice(1).join(\":\"));\n\t\t\t}\n\n\t\t\tfor (const key of updateKeys) {\n\t\t\t\tconst withoutPrefix = key.slice(UPDATE_PREFIX.length);\n\t\t\t\tconst parts = withoutPrefix.split(\":\");\n\t\t\t\tdocIds.add(parts.slice(1, -1).join(\":\"));\n\t\t\t}\n\n\t\t\treturn Array.from(docIds);\n\t\t},\n\t\tkv: new AdapterKeyValueStore(adapter),\n\t};\n}\n","export interface PRFCredential {\n\tid: string;\n\trawId: Uint8Array;\n\tsalt: Uint8Array;\n}\n\nexport interface PRFResult {\n\tcredential: PRFCredential;\n\tkey: Uint8Array;\n}\n\nconst REPLICATE_RP_NAME = \"Replicate Encryption\";\n\nfunction getRpId(): string {\n\tif (typeof window === \"undefined\") return \"localhost\";\n\treturn window.location.hostname;\n}\n\nfunction generateSalt(): Uint8Array {\n\treturn crypto.getRandomValues(new Uint8Array(32));\n}\n\nfunction generateUserId(): Uint8Array {\n\treturn crypto.getRandomValues(new Uint8Array(32));\n}\n\nexport async function isPRFSupported(): Promise<boolean> {\n\tif (typeof window === \"undefined\") return false;\n\tif (typeof PublicKeyCredential === \"undefined\") return false;\n\n\tif (typeof PublicKeyCredential.getClientCapabilities === \"function\") {\n\t\ttry {\n\t\t\tconst caps = await PublicKeyCredential.getClientCapabilities();\n\t\t\treturn caps[\"extension:prf\"] === true;\n\t\t} catch {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nexport async function createPRFCredential(userName: string): Promise<PRFCredential> {\n\tconst supported = await isPRFSupported();\n\tif (!supported) {\n\t\tthrow new Error(\"WebAuthn PRF not supported\");\n\t}\n\n\tlet credential: PublicKeyCredential | null;\n\n\ttry {\n\t\tcredential = (await navigator.credentials.create({\n\t\t\tpublicKey: {\n\t\t\t\trp: {\n\t\t\t\t\tname: REPLICATE_RP_NAME,\n\t\t\t\t\tid: getRpId(),\n\t\t\t\t},\n\t\t\t\tuser: {\n\t\t\t\t\tid: generateUserId().buffer as ArrayBuffer,\n\t\t\t\t\tname: userName,\n\t\t\t\t\tdisplayName: userName,\n\t\t\t\t},\n\t\t\t\tchallenge: crypto.getRandomValues(new Uint8Array(32)).buffer as ArrayBuffer,\n\t\t\t\tpubKeyCredParams: [\n\t\t\t\t\t{ alg: -7, type: \"public-key\" },\n\t\t\t\t\t{ alg: -257, type: \"public-key\" },\n\t\t\t\t],\n\t\t\t\tauthenticatorSelection: {\n\t\t\t\t\tresidentKey: \"required\",\n\t\t\t\t\tuserVerification: \"required\",\n\t\t\t\t},\n\t\t\t\textensions: { prf: {} },\n\t\t\t},\n\t\t})) as PublicKeyCredential | null;\n\t} catch (err) {\n\t\tif (err instanceof DOMException) {\n\t\t\tswitch (err.name) {\n\t\t\t\tcase \"NotAllowedError\":\n\t\t\t\t\tthrow new Error(\"Setup cancelled or denied\");\n\t\t\t\tcase \"SecurityError\":\n\t\t\t\t\tthrow new Error(\"Security error: ensure you're using HTTPS\");\n\t\t\t\tcase \"AbortError\":\n\t\t\t\t\tthrow new Error(\"Setup timed out\");\n\t\t\t\tcase \"InvalidStateError\":\n\t\t\t\t\tthrow new Error(\"Credential already exists for this account\");\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error(`WebAuthn error: ${err.message}`);\n\t\t\t}\n\t\t}\n\t\tthrow err;\n\t}\n\n\tif (!credential) {\n\t\tthrow new Error(\"Credential creation cancelled\");\n\t}\n\n\tconst prfEnabled = (credential.getClientExtensionResults() as { prf?: { enabled?: boolean } }).prf\n\t\t?.enabled;\n\tif (!prfEnabled) {\n\t\tthrow new Error(\"PRF extension not enabled - authenticator may not support PRF\");\n\t}\n\n\treturn {\n\t\tid: credential.id,\n\t\trawId: new Uint8Array(credential.rawId),\n\t\tsalt: generateSalt(),\n\t};\n}\n\nexport async function getPRFKey(credential: PRFCredential): Promise<Uint8Array> {\n\tlet assertion: PublicKeyCredential | null;\n\n\ttry {\n\t\tassertion = (await navigator.credentials.get({\n\t\t\tpublicKey: {\n\t\t\t\tchallenge: crypto.getRandomValues(new Uint8Array(32)).buffer as ArrayBuffer,\n\t\t\t\tallowCredentials: [\n\t\t\t\t\t{\n\t\t\t\t\t\tid: credential.rawId.buffer as ArrayBuffer,\n\t\t\t\t\t\ttype: \"public-key\",\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\textensions: {\n\t\t\t\t\tprf: {\n\t\t\t\t\t\teval: { first: credential.salt.buffer as ArrayBuffer },\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tuserVerification: \"required\",\n\t\t\t},\n\t\t})) as PublicKeyCredential | null;\n\t} catch (err) {\n\t\tif (err instanceof DOMException) {\n\t\t\tswitch (err.name) {\n\t\t\t\tcase \"NotAllowedError\":\n\t\t\t\t\tthrow new Error(\"Authentication cancelled or denied\");\n\t\t\t\tcase \"SecurityError\":\n\t\t\t\t\tthrow new Error(\"Security error: ensure you're using HTTPS\");\n\t\t\t\tcase \"AbortError\":\n\t\t\t\t\tthrow new Error(\"Authentication timed out\");\n\t\t\t\tcase \"InvalidStateError\":\n\t\t\t\t\tthrow new Error(\"Authenticator not available\");\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error(`WebAuthn error: ${err.message}`);\n\t\t\t}\n\t\t}\n\t\tthrow err;\n\t}\n\n\tif (!assertion) {\n\t\tthrow new Error(\"Authentication cancelled\");\n\t}\n\n\tconst prfResults = (\n\t\tassertion.getClientExtensionResults() as {\n\t\t\tprf?: { results?: { first?: ArrayBuffer } };\n\t\t}\n\t).prf?.results?.first;\n\n\tif (!prfResults) {\n\t\tthrow new Error(\"PRF output not available - authenticator may not support PRF\");\n\t}\n\n\treturn new Uint8Array(prfResults);\n}\n\nexport async function deriveEncryptionKey(prfOutput: Uint8Array, info: string): Promise<CryptoKey> {\n\tconst keyMaterial = await crypto.subtle.importKey(\n\t\t\"raw\",\n\t\tprfOutput.buffer as ArrayBuffer,\n\t\t\"HKDF\",\n\t\tfalse,\n\t\t[\"deriveKey\"],\n\t);\n\n\treturn crypto.subtle.deriveKey(\n\t\t{\n\t\t\tname: \"HKDF\",\n\t\t\thash: \"SHA-256\",\n\t\t\tsalt: new Uint8Array(32),\n\t\t\tinfo: new TextEncoder().encode(info),\n\t\t},\n\t\tkeyMaterial,\n\t\t{ name: \"AES-GCM\", length: 256 },\n\t\tfalse,\n\t\t[\"encrypt\", \"decrypt\"],\n\t);\n}\n","const IV_LENGTH = 12;\nconst SALT_LENGTH = 16;\n\nexport async function deriveKeyFromPassphrase(\n\tpassphrase: string,\n\tsalt: Uint8Array,\n): Promise<CryptoKey> {\n\tconst encoder = new TextEncoder();\n\tconst keyMaterial = await crypto.subtle.importKey(\n\t\t\"raw\",\n\t\tencoder.encode(passphrase),\n\t\t\"PBKDF2\",\n\t\tfalse,\n\t\t[\"deriveKey\"],\n\t);\n\n\treturn crypto.subtle.deriveKey(\n\t\t{\n\t\t\tname: \"PBKDF2\",\n\t\t\tsalt: salt.buffer as ArrayBuffer,\n\t\t\titerations: 100000,\n\t\t\thash: \"SHA-256\",\n\t\t},\n\t\tkeyMaterial,\n\t\t{ name: \"AES-GCM\", length: 256 },\n\t\tfalse,\n\t\t[\"encrypt\", \"decrypt\"],\n\t);\n}\n\nexport async function encrypt(key: CryptoKey, data: Uint8Array): Promise<Uint8Array> {\n\tconst iv = crypto.getRandomValues(new Uint8Array(IV_LENGTH));\n\tconst encrypted = await crypto.subtle.encrypt(\n\t\t{ name: \"AES-GCM\", iv },\n\t\tkey,\n\t\tdata.buffer as ArrayBuffer,\n\t);\n\n\tconst result = new Uint8Array(IV_LENGTH + encrypted.byteLength);\n\tresult.set(iv, 0);\n\tresult.set(new Uint8Array(encrypted), IV_LENGTH);\n\treturn result;\n}\n\nexport async function decrypt(key: CryptoKey, data: Uint8Array): Promise<Uint8Array> {\n\tconst iv = data.slice(0, IV_LENGTH);\n\tconst encrypted = data.slice(IV_LENGTH);\n\n\tconst decrypted = await crypto.subtle.decrypt(\n\t\t{ name: \"AES-GCM\", iv },\n\t\tkey,\n\t\tencrypted.buffer as ArrayBuffer,\n\t);\n\treturn new Uint8Array(decrypted);\n}\n\nexport function generateSalt(): Uint8Array {\n\treturn crypto.getRandomValues(new Uint8Array(SALT_LENGTH));\n}\n\nexport function generateRecoveryKey(): string {\n\tconst bytes = crypto.getRandomValues(new Uint8Array(20));\n\tconst chars = \"ABCDEFGHJKLMNPQRSTUVWXYZ23456789\";\n\tlet result = \"\";\n\tfor (let i = 0; i < bytes.length; i++) {\n\t\tif (i > 0 && i % 4 === 0) result += \"-\";\n\t\tresult += chars[bytes[i] % chars.length];\n\t}\n\treturn result;\n}\n\nexport async function hashRecoveryKey(recoveryKey: string): Promise<Uint8Array> {\n\tconst normalized = recoveryKey.replace(/-/g, \"\").toUpperCase();\n\tconst encoded = new TextEncoder().encode(normalized);\n\tconst hash = await crypto.subtle.digest(\"SHA-256\", encoded);\n\treturn new Uint8Array(hash);\n}\n","import * as Y from \"yjs\";\nimport type { Persistence, PersistenceProvider, KeyValueStore } from \"../types.js\";\nimport type { WebEncryptionConfig, EncryptionPersistence, EncryptionState } from \"./types.js\";\nimport {\n\tisPRFSupported,\n\tcreatePRFCredential,\n\tgetPRFKey,\n\tderiveEncryptionKey,\n\ttype PRFCredential,\n} from \"./webauthn.js\";\nimport {\n\tencrypt,\n\tdecrypt,\n\tgenerateSalt,\n\tgenerateRecoveryKey,\n\tderiveKeyFromPassphrase,\n} from \"./crypto.js\";\n\nconst CREDENTIAL_KEY = \"webauthn:credential\";\nconst SALT_KEY = \"encryption:salt\";\nconst SETUP_KEY = \"encryption:setup\";\nconst DOC_PREFIX = \"enc:doc:\";\n\ninterface StoredCredential {\n\tid: string;\n\trawId: number[];\n\tsalt: number[];\n}\n\nfunction serializeCredential(cred: PRFCredential): StoredCredential {\n\treturn {\n\t\tid: cred.id,\n\t\trawId: Array.from(cred.rawId),\n\t\tsalt: Array.from(cred.salt),\n\t};\n}\n\nfunction deserializeCredential(stored: StoredCredential): PRFCredential {\n\treturn {\n\t\tid: stored.id,\n\t\trawId: new Uint8Array(stored.rawId),\n\t\tsalt: new Uint8Array(stored.salt),\n\t};\n}\n\nclass EncryptedKeyValueStore implements KeyValueStore {\n\tconstructor(\n\t\tprivate inner: KeyValueStore,\n\t\tprivate getKey: () => CryptoKey | null,\n\t) {}\n\n\tasync get<T>(key: string): Promise<T | undefined> {\n\t\tconst encryptionKey = this.getKey();\n\t\tif (!encryptionKey) return undefined;\n\n\t\tconst encrypted = await this.inner.get<number[]>(key);\n\t\tif (!encrypted) return undefined;\n\n\t\ttry {\n\t\t\tconst decrypted = await decrypt(encryptionKey, new Uint8Array(encrypted));\n\t\t\treturn JSON.parse(new TextDecoder().decode(decrypted)) as T;\n\t\t} catch {\n\t\t\treturn undefined;\n\t\t}\n\t}\n\n\tasync set<T>(key: string, value: T): Promise<void> {\n\t\tconst encryptionKey = this.getKey();\n\t\tif (!encryptionKey) throw new Error(\"Encryption locked\");\n\n\t\tconst data = new TextEncoder().encode(JSON.stringify(value));\n\t\tconst encrypted = await encrypt(encryptionKey, data);\n\t\tawait this.inner.set(key, Array.from(encrypted));\n\t}\n\n\tasync del(key: string): Promise<void> {\n\t\tawait this.inner.del(key);\n\t}\n}\n\nclass EncryptedPersistenceProvider implements PersistenceProvider {\n\tprivate updateHandler: (update: Uint8Array, origin: unknown) => void;\n\tprivate pendingWrites: Promise<void>[] = [];\n\treadonly whenSynced: Promise<void>;\n\n\tconstructor(\n\t\tprivate innerStorage: Persistence,\n\t\tprivate collection: string,\n\t\tprivate ydoc: Y.Doc,\n\t\tprivate encryptionKey: CryptoKey,\n\t) {\n\t\tthis.whenSynced = this.loadState();\n\n\t\tthis.updateHandler = (update: Uint8Array, origin: unknown) => {\n\t\t\tif (origin !== \"encrypted-load\") {\n\t\t\t\tconst writePromise = this.saveUpdate(update).catch((err: Error) => {\n\t\t\t\t\tconsole.error(\"[EncryptedPersistence] Save failed:\", err);\n\t\t\t\t});\n\t\t\t\tthis.pendingWrites.push(writePromise);\n\t\t\t\twritePromise.finally(() => {\n\t\t\t\t\tthis.pendingWrites = this.pendingWrites.filter(p => p !== writePromise);\n\t\t\t\t});\n\t\t\t}\n\t\t};\n\t\tthis.ydoc.on(\"update\", this.updateHandler);\n\t}\n\n\tprivate async loadState(): Promise<void> {\n\t\tconst snapshotKey = `${DOC_PREFIX}${this.collection}:snapshot`;\n\t\tconst deltasKey = `${DOC_PREFIX}${this.collection}:deltas`;\n\n\t\tconst encryptedSnapshot = await this.innerStorage.kv.get<number[]>(snapshotKey);\n\t\tif (encryptedSnapshot) {\n\t\t\tconst decrypted = await decrypt(this.encryptionKey, new Uint8Array(encryptedSnapshot));\n\t\t\tY.applyUpdate(this.ydoc, decrypted, \"encrypted-load\");\n\t\t}\n\n\t\tconst encryptedDeltas = await this.innerStorage.kv.get<number[][]>(deltasKey);\n\t\tif (encryptedDeltas) {\n\t\t\tfor (const encDelta of encryptedDeltas) {\n\t\t\t\tconst decrypted = await decrypt(this.encryptionKey, new Uint8Array(encDelta));\n\t\t\t\tY.applyUpdate(this.ydoc, decrypted, \"encrypted-load\");\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate async saveUpdate(update: Uint8Array): Promise<void> {\n\t\tconst deltasKey = `${DOC_PREFIX}${this.collection}:deltas`;\n\n\t\tconst encrypted = await encrypt(this.encryptionKey, update);\n\t\tconst existingDeltas = (await this.innerStorage.kv.get<number[][]>(deltasKey)) ?? [];\n\t\texistingDeltas.push(Array.from(encrypted));\n\t\tawait this.innerStorage.kv.set(deltasKey, existingDeltas);\n\n\t\tif (existingDeltas.length >= 50) {\n\t\t\tawait this.compact();\n\t\t}\n\t}\n\n\tprivate async compact(): Promise<void> {\n\t\tconst snapshotKey = `${DOC_PREFIX}${this.collection}:snapshot`;\n\t\tconst deltasKey = `${DOC_PREFIX}${this.collection}:deltas`;\n\n\t\tconst snapshot = Y.encodeStateAsUpdate(this.ydoc);\n\t\tconst encrypted = await encrypt(this.encryptionKey, snapshot);\n\n\t\tawait this.innerStorage.kv.set(snapshotKey, Array.from(encrypted));\n\t\tawait this.innerStorage.kv.del(deltasKey);\n\t}\n\n\tasync flush(): Promise<void> {\n\t\tawait Promise.all(this.pendingWrites);\n\t}\n\n\tdestroy(): void {\n\t\tthis.ydoc.off(\"update\", this.updateHandler);\n\t}\n}\n\nexport async function createWebEncryptionPersistence(\n\tconfig: WebEncryptionConfig,\n): Promise<EncryptionPersistence> {\n\tconst { storage, user, unlock, recovery, lock: lockConfig, onLock, onUnlock } = config;\n\n\tlet encryptionKey: CryptoKey | null = null;\n\tlet idleTimer: ReturnType<typeof setTimeout> | null = null;\n\n\tconst isSetup = await storage.kv.get<boolean>(SETUP_KEY);\n\tlet state: EncryptionState = isSetup ? \"locked\" : \"setup\";\n\n\tconst resetIdleTimer = () => {\n\t\tif (!lockConfig?.idle) return;\n\t\tif (idleTimer) clearTimeout(idleTimer);\n\t\tidleTimer = setTimeout(\n\t\t\t() => {\n\t\t\t\tvoid doLock();\n\t\t\t},\n\t\t\tlockConfig.idle * 60 * 1000,\n\t\t);\n\t};\n\n\tconst doLock = async () => {\n\t\tencryptionKey = null;\n\t\tstate = \"locked\";\n\t\tif (idleTimer) {\n\t\t\tclearTimeout(idleTimer);\n\t\t\tidleTimer = null;\n\t\t}\n\t\tonLock?.();\n\t};\n\n\tconst doUnlock = async () => {\n\t\tconst isSetup = await storage.kv.get<boolean>(SETUP_KEY);\n\n\t\tif (!isSetup) {\n\t\t\tstate = \"setup\";\n\n\t\t\tif (unlock.webauthn) {\n\t\t\t\tconst supported = await isPRFSupported();\n\t\t\t\tif (supported) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst credential = await createPRFCredential(user);\n\t\t\t\t\t\tconst prfKey = await getPRFKey(credential);\n\t\t\t\t\t\tencryptionKey = await deriveEncryptionKey(prfKey, `replicate:${user}`);\n\n\t\t\t\t\t\tawait storage.kv.set(CREDENTIAL_KEY, serializeCredential(credential));\n\t\t\t\t\t\tawait storage.kv.set(SETUP_KEY, true);\n\n\t\t\t\t\t\tif (recovery) {\n\t\t\t\t\t\t\tconst recoveryKey = generateRecoveryKey();\n\t\t\t\t\t\t\tawait recovery.onSetup(recoveryKey);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tstate = \"unlocked\";\n\t\t\t\t\t\tresetIdleTimer();\n\t\t\t\t\t\tonUnlock?.();\n\t\t\t\t\t\treturn;\n\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\tif (!unlock.passphrase) {\n\t\t\t\t\t\t\tthrow err;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (unlock.passphrase) {\n\t\t\t\tconst salt = generateSalt();\n\t\t\t\tconst passphrase = await unlock.passphrase.setup(recovery ? generateRecoveryKey() : \"\");\n\t\t\t\tencryptionKey = await deriveKeyFromPassphrase(passphrase, salt);\n\n\t\t\t\tawait storage.kv.set(SALT_KEY, Array.from(salt));\n\t\t\t\tawait storage.kv.set(SETUP_KEY, true);\n\n\t\t\t\tstate = \"unlocked\";\n\t\t\t\tresetIdleTimer();\n\t\t\t\tonUnlock?.();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthrow new Error(\"No unlock method available\");\n\t\t}\n\n\t\tif (unlock.webauthn) {\n\t\t\tconst storedCred = await storage.kv.get<StoredCredential>(CREDENTIAL_KEY);\n\t\t\tif (storedCred) {\n\t\t\t\ttry {\n\t\t\t\t\tconst credential = deserializeCredential(storedCred);\n\t\t\t\t\tconst prfKey = await getPRFKey(credential);\n\t\t\t\t\tencryptionKey = await deriveEncryptionKey(prfKey, `replicate:${user}`);\n\n\t\t\t\t\tstate = \"unlocked\";\n\t\t\t\t\tresetIdleTimer();\n\t\t\t\t\tonUnlock?.();\n\t\t\t\t\treturn;\n\t\t\t\t} catch (err) {\n\t\t\t\t\tif (!unlock.passphrase) {\n\t\t\t\t\t\tthrow err;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (!unlock.passphrase) {\n\t\t\t\tthrow new Error(\"WebAuthn credential not found. Set up encryption again.\");\n\t\t\t}\n\t\t}\n\n\t\tif (unlock.passphrase) {\n\t\t\tconst saltArray = await storage.kv.get<number[]>(SALT_KEY);\n\t\t\tif (!saltArray) {\n\t\t\t\tthrow new Error(\"Encryption data not found. Set up encryption again.\");\n\t\t\t}\n\t\t\tconst salt = new Uint8Array(saltArray);\n\t\t\tconst passphrase = await unlock.passphrase.get();\n\t\t\tencryptionKey = await deriveKeyFromPassphrase(passphrase, salt);\n\n\t\t\tstate = \"unlocked\";\n\t\t\tresetIdleTimer();\n\t\t\tonUnlock?.();\n\t\t\treturn;\n\t\t}\n\n\t\tthrow new Error(\"No unlock method configured\");\n\t};\n\n\tconst encryptedKv = new EncryptedKeyValueStore(storage.kv, () => encryptionKey);\n\n\treturn {\n\t\tget state() {\n\t\t\treturn state;\n\t\t},\n\n\t\tasync lock() {\n\t\t\tawait doLock();\n\t\t},\n\n\t\tasync unlock() {\n\t\t\tawait doUnlock();\n\t\t},\n\n\t\tasync isSupported() {\n\t\t\tif (unlock.webauthn) {\n\t\t\t\treturn isPRFSupported();\n\t\t\t}\n\t\t\treturn true;\n\t\t},\n\n\t\tcreateDocPersistence(collection: string, ydoc: Y.Doc): PersistenceProvider {\n\t\t\tif (!encryptionKey) {\n\t\t\t\tthrow new Error(\"Encryption locked - call unlock() first\");\n\t\t\t}\n\t\t\treturn new EncryptedPersistenceProvider(storage, collection, ydoc, encryptionKey);\n\t\t},\n\n\t\tasync listDocuments(prefix: string): Promise<string[]> {\n\t\t\tconst keys = await storage.listDocuments(prefix);\n\t\t\treturn keys;\n\t\t},\n\n\t\tkv: encryptedKv,\n\t};\n}\n","import type { Persistence } from \"../types.js\";\nimport type { EncryptionPersistence, EncryptionState, WebEncryptionConfig } from \"./types.js\";\nimport { createWebEncryptionPersistence } from \"./web.js\";\nimport { isPRFSupported } from \"./webauthn.js\";\n\nexport type EncryptionPreference = \"webauthn\" | \"passphrase\" | \"none\";\n\nexport interface EncryptionManagerHooks {\n\tchange?: (state: EncryptionManagerState) => void;\n\tpassphrase?: () => Promise<string>;\n\trecovery?: (key: string) => void;\n}\n\nexport interface EncryptionManagerConfig {\n\tstorage: Persistence;\n\tuser: string;\n\tpreference?: EncryptionPreference;\n\thooks?: EncryptionManagerHooks;\n}\n\nexport interface EncryptionManagerState {\n\tstate: EncryptionState | \"disabled\";\n\terror?: Error;\n\tpersistence: Persistence;\n}\n\nexport interface EncryptionManager {\n\tget(): EncryptionManagerState;\n\tenable(): Promise<void>;\n\tdisable(): Promise<void>;\n\tunlock(): Promise<void>;\n\tlock(): Promise<void>;\n\tsubscribe(callback: (state: EncryptionManagerState) => void): () => void;\n\tdestroy(): void;\n}\n\nconst ENABLED_KEY = \"encryption:manager:enabled\";\n\nexport async function createEncryptionManager(\n\tconfig: EncryptionManagerConfig,\n): Promise<EncryptionManager> {\n\tconst { storage, user, preference = \"webauthn\", hooks } = config;\n\n\tlet encryptedPersistence: EncryptionPersistence | null = null;\n\tlet currentState: EncryptionManagerState = {\n\t\tstate: \"disabled\",\n\t\tpersistence: storage,\n\t};\n\n\tconst subscribers = new Set<(state: EncryptionManagerState) => void>();\n\n\tconst notify = (): void => {\n\t\tsubscribers.forEach(cb => cb(currentState));\n\t\thooks?.change?.(currentState);\n\t};\n\n\tconst updateState = (updates: Partial<EncryptionManagerState>): void => {\n\t\tcurrentState = { ...currentState, ...updates };\n\t\tnotify();\n\t};\n\n\tconst isEnabled = await storage.kv.get<boolean>(ENABLED_KEY);\n\n\tif (isEnabled && preference !== \"none\") {\n\t\ttry {\n\t\t\tconst encryptionConfig = await buildEncryptionConfig(storage, user, preference, hooks);\n\t\t\tencryptedPersistence = await createWebEncryptionPersistence(encryptionConfig);\n\n\t\t\tupdateState({\n\t\t\t\tstate: encryptedPersistence.state,\n\t\t\t\tpersistence: encryptedPersistence,\n\t\t\t});\n\t\t} catch (err) {\n\t\t\tupdateState({\n\t\t\t\tstate: \"disabled\",\n\t\t\t\terror: err instanceof Error ? err : new Error(String(err)),\n\t\t\t\tpersistence: storage,\n\t\t\t});\n\t\t}\n\t}\n\n\treturn {\n\t\tget(): EncryptionManagerState {\n\t\t\treturn currentState;\n\t\t},\n\n\t\tasync enable(): Promise<void> {\n\t\t\tif (encryptedPersistence) return;\n\n\t\t\ttry {\n\t\t\t\tconst encryptionConfig = await buildEncryptionConfig(storage, user, preference, hooks);\n\t\t\t\tencryptedPersistence = await createWebEncryptionPersistence(encryptionConfig);\n\n\t\t\t\tawait storage.kv.set(ENABLED_KEY, true);\n\n\t\t\t\tawait encryptedPersistence.unlock();\n\n\t\t\t\tupdateState({\n\t\t\t\t\tstate: encryptedPersistence.state,\n\t\t\t\t\terror: undefined,\n\t\t\t\t\tpersistence: encryptedPersistence,\n\t\t\t\t});\n\t\t\t} catch (err) {\n\t\t\t\tupdateState({\n\t\t\t\t\tstate: \"disabled\",\n\t\t\t\t\terror: err instanceof Error ? err : new Error(String(err)),\n\t\t\t\t\tpersistence: storage,\n\t\t\t\t});\n\t\t\t\tthrow err;\n\t\t\t}\n\t\t},\n\n\t\tasync disable(): Promise<void> {\n\t\t\tif (encryptedPersistence) {\n\t\t\t\tawait encryptedPersistence.lock();\n\t\t\t\tencryptedPersistence = null;\n\t\t\t}\n\n\t\t\tawait storage.kv.del(ENABLED_KEY);\n\n\t\t\tupdateState({\n\t\t\t\tstate: \"disabled\",\n\t\t\t\terror: undefined,\n\t\t\t\tpersistence: storage,\n\t\t\t});\n\t\t},\n\n\t\tasync unlock(): Promise<void> {\n\t\t\tif (!encryptedPersistence) {\n\t\t\t\tthrow new Error(\"Encryption not enabled. Call enable() first.\");\n\t\t\t}\n\n\t\t\tawait encryptedPersistence.unlock();\n\n\t\t\tupdateState({\n\t\t\t\tstate: encryptedPersistence.state,\n\t\t\t\terror: undefined,\n\t\t\t\tpersistence: encryptedPersistence,\n\t\t\t});\n\t\t},\n\n\t\tasync lock(): Promise<void> {\n\t\t\tif (!encryptedPersistence) return;\n\n\t\t\tawait encryptedPersistence.lock();\n\n\t\t\tupdateState({\n\t\t\t\tstate: encryptedPersistence.state,\n\t\t\t\tpersistence: encryptedPersistence,\n\t\t\t});\n\t\t},\n\n\t\tsubscribe(callback: (state: EncryptionManagerState) => void): () => void {\n\t\t\tsubscribers.add(callback);\n\t\t\tcallback(currentState);\n\t\t\treturn () => subscribers.delete(callback);\n\t\t},\n\n\t\tdestroy(): void {\n\t\t\tsubscribers.clear();\n\t\t},\n\t};\n}\n\nasync function buildEncryptionConfig(\n\tstorage: Persistence,\n\tuser: string,\n\tpreference: EncryptionPreference,\n\thooks?: EncryptionManagerHooks,\n): Promise<WebEncryptionConfig> {\n\tconst webauthnSupported = preference === \"webauthn\" && (await isPRFSupported());\n\n\tconst config: WebEncryptionConfig = {\n\t\tstorage,\n\t\tuser,\n\t\tmode: \"local\",\n\t\tunlock: {},\n\t};\n\n\tif (webauthnSupported) {\n\t\tconfig.unlock.webauthn = true;\n\t}\n\n\tif (hooks?.passphrase || !webauthnSupported) {\n\t\tconfig.unlock.passphrase = {\n\t\t\tget: async () => {\n\t\t\t\tif (hooks?.passphrase) {\n\t\t\t\t\treturn hooks.passphrase();\n\t\t\t\t}\n\t\t\t\tthrow new Error(\"Passphrase hook not configured\");\n\t\t\t},\n\t\t\tsetup: async (recoveryKey: string) => {\n\t\t\t\tif (hooks?.recovery) {\n\t\t\t\t\thooks.recovery(recoveryKey);\n\t\t\t\t}\n\t\t\t\tif (hooks?.passphrase) {\n\t\t\t\t\treturn hooks.passphrase();\n\t\t\t\t}\n\t\t\t\tthrow new Error(\"Passphrase hook not configured\");\n\t\t\t},\n\t\t};\n\t}\n\n\tif (hooks?.recovery) {\n\t\tconfig.recovery = {\n\t\t\tonSetup: async (key: string) => {\n\t\t\t\thooks.recovery!(key);\n\t\t\t},\n\t\t\tonRecover: async () => {\n\t\t\t\tif (hooks?.passphrase) {\n\t\t\t\t\treturn hooks.passphrase();\n\t\t\t\t}\n\t\t\t\tthrow new Error(\"Recovery requires passphrase hook\");\n\t\t\t},\n\t\t};\n\t}\n\n\treturn config;\n}\n","export type { StorageAdapter, Persistence } from \"./types.js\";\n\nimport { memoryPersistence } from \"./memory.js\";\nimport { createNativeSqlitePersistence } from \"./sqlite/native.js\";\nimport { createWebSqlitePersistence, onceWebSqlitePersistence } from \"./sqlite/web.js\";\nimport { createCustomPersistence } from \"./custom.js\";\nimport { createWebEncryptionPersistence } from \"./encrypted/web.js\";\nimport { isPRFSupported } from \"./encrypted/webauthn.js\";\nimport { createEncryptionManager } from \"./encrypted/manager.js\";\n\nexport type {\n\tWebEncryptionConfig,\n\tNativeEncryptionConfig,\n\tEncryptionPersistence,\n\tEncryptionState,\n} from \"./encrypted/types.js\";\n\nexport type {\n\tEncryptionManager,\n\tEncryptionManagerConfig,\n\tEncryptionManagerState,\n\tEncryptionManagerHooks,\n\tEncryptionPreference,\n} from \"./encrypted/manager.js\";\n\nexport const persistence = {\n\tweb: {\n\t\tsqlite: {\n\t\t\tcreate: createWebSqlitePersistence,\n\t\t\tonce: onceWebSqlitePersistence,\n\t\t},\n\t\tencryption: {\n\t\t\tcreate: createWebEncryptionPersistence,\n\t\t\tmanager: createEncryptionManager,\n\t\t\twebauthn: {\n\t\t\t\tsupported: isPRFSupported,\n\t\t\t},\n\t\t},\n\t},\n\tnative: {\n\t\tsqlite: {\n\t\t\tcreate: createNativeSqlitePersistence,\n\t\t},\n\t\tencryption: {\n\t\t\tcreate: (): never => {\n\t\t\t\tthrow new Error(\"persistence.native.encryption.create() not yet implemented\");\n\t\t\t},\n\t\t\tbiometric: {\n\t\t\t\tsupported: (): Promise<boolean> => Promise.resolve(false),\n\t\t\t},\n\t\t},\n\t},\n\tmemory: {\n\t\tcreate: memoryPersistence,\n\t},\n\tcustom: {\n\t\tcreate: createCustomPersistence,\n\t},\n} as const;\n","export {\n\tcollection,\n\ttype EditorBinding,\n\ttype ConvexCollection,\n\ttype LazyCollection,\n\ttype Materialized,\n\ttype PaginatedPage,\n\ttype PaginatedMaterial,\n\ttype PaginationConfig,\n\ttype PaginationStatus,\n\ttype ProseOptions,\n\ttype DocumentHandle,\n\ttype DocumentPresence,\n\ttype PresenceState,\n\ttype SessionInfo,\n\ttype SessionAPI,\n} from \"$/client/collection\";\n\nexport type { DocFromSchema, TableNamesFromSchema, InferDoc } from \"$/client/types\";\n\nexport { identity, type UserIdentity, type AnonymousPresenceConfig } from \"$/client/identity\";\n\nexport { type Seq } from \"$/client/services/seq\";\n\nimport {\n\tNetworkError,\n\tIDBError,\n\tIDBWriteError,\n\tReconciliationError,\n\tProseError,\n\tCollectionNotReadyError,\n\tNonRetriableError,\n} from \"$/client/errors\";\n\nexport const errors = {\n\tNetwork: NetworkError,\n\tIDB: IDBError,\n\tIDBWrite: IDBWriteError,\n\tReconciliation: ReconciliationError,\n\tProse: ProseError,\n\tCollectionNotReady: CollectionNotReadyError,\n\tNonRetriable: NonRetriableError,\n} as const;\n\nimport { extract } from \"$/client/merge\";\nimport { emptyProse } from \"$/client/validators\";\n\nexport const schema = {\n\tprose: {\n\t\textract,\n\t\tempty: emptyProse,\n\t},\n} as const;\n\nexport {\n\tpersistence,\n\ttype StorageAdapter,\n\ttype Persistence,\n\ttype EncryptionPersistence,\n\ttype EncryptionState,\n\ttype WebEncryptionConfig,\n\ttype NativeEncryptionConfig,\n\ttype EncryptionManager,\n\ttype EncryptionManagerConfig,\n\ttype EncryptionManagerState,\n\ttype EncryptionManagerHooks,\n\ttype EncryptionPreference,\n} from \"$/client/persistence/index\";\n\n// Migration types and functions\nexport type {\n\tMigrationErrorCode,\n\tMigrationError,\n\tRecoveryContext,\n\tRecoveryAction,\n\tMigrationErrorHandler,\n\tMigrationDatabase,\n\tMigrationDoc,\n\tClientMigrationContext,\n\tClientMigrationFn,\n\tClientMigrationMap,\n\tVersionedCollectionOptions,\n\tVersionedCollectionConfig,\n\tSchemaMetadata,\n\tRunMigrationsOptions,\n\tMigrationResult,\n} from \"$/client/migration\";\n\nexport {\n\trunMigrations,\n\tgetStoredSchemaVersion,\n\tsetStoredSchemaVersion,\n\trunAutoMigration,\n\tcreateMigrationError,\n} from \"$/client/migration\";\n\nexport { getLogger, type Logger } from \"$/shared/logger\";\n"],"mappings":"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"}