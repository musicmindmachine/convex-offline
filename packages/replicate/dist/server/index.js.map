{"version":3,"file":"index.js","names":["DURATION_MULTIPLIERS: Record<DurationUnit, number>","v","operations: SchemaDiffOperation[]","generatedSQL: string[]","allVersions: Record<number, GenericValidator>","versionedSchema: VersionedSchema<TShape>","component: any","collectionName: string","collection","docs","existing","result"],"sources":["../../src/shared/index.ts","../../src/server/collection.ts","../../src/server/schema.ts","../../src/server/migration.ts","../../src/server/index.ts"],"sourcesContent":["/**\n * @trestleinc/replicate - Shared Module\n *\n * Single source of truth for all validators, types, and utilities.\n *\n * Following the val.md pattern:\n * 1. All validators defined here\n * 2. Types derived from validators using Infer<>\n * 3. No duplicate interfaces - types come from validators\n */\n\nimport { type Infer, v } from \"convex/values\";\n\n// ============================================================================\n// Core Validators (used across component, server, client)\n// ============================================================================\n\n/**\n * Profile validator for user presence/identity.\n * Used in sessions and presence tracking.\n */\nexport const profileValidator = v.object({\n\tname: v.optional(v.string()),\n\tcolor: v.optional(v.string()),\n\tavatar: v.optional(v.string()),\n});\n\n/**\n * Cursor validator for collaborative editing positions.\n * Tracks anchor/head selection positions and optional field context.\n */\nexport const cursorValidator = v.object({\n\tanchor: v.any(),\n\thead: v.any(),\n\tfield: v.optional(v.string()),\n});\n\n/**\n * Prose validator for ProseMirror-compatible rich text JSON.\n * Used for collaborative rich text editing fields.\n */\nexport const proseValidator = v.object({\n\ttype: v.literal(\"doc\"),\n\tcontent: v.optional(v.array(v.any())),\n});\n\n// ============================================================================\n// Stream/Sync Validators\n// ============================================================================\n\n/**\n * Individual change in a stream response.\n */\nexport const streamChangeValidator = v.object({\n\tdocument: v.string(),\n\tbytes: v.bytes(),\n\tseq: v.number(),\n\ttype: v.string(),\n});\n\n/**\n * Extended stream change with existence flag (used in server responses).\n */\nexport const streamChangeWithExistsValidator = v.object({\n\tdocument: v.string(),\n\tbytes: v.bytes(),\n\tseq: v.number(),\n\ttype: v.string(),\n\texists: v.boolean(),\n});\n\n/**\n * Stream query result with changes, cursor, and compaction hints.\n */\nexport const streamResultValidator = v.object({\n\tchanges: v.array(streamChangeValidator),\n\tseq: v.number(),\n\tmore: v.boolean(),\n\tcompact: v.optional(\n\t\tv.object({\n\t\t\tdocuments: v.array(v.string()),\n\t\t}),\n\t),\n});\n\n/**\n * Stream result with exists flag on changes (server-enriched response).\n */\nexport const streamResultWithExistsValidator = v.object({\n\tchanges: v.array(streamChangeWithExistsValidator),\n\tseq: v.number(),\n\tmore: v.boolean(),\n\tcompact: v.optional(\n\t\tv.object({\n\t\t\tdocuments: v.array(v.string()),\n\t\t}),\n\t),\n});\n\n// ============================================================================\n// Session/Presence Validators\n// ============================================================================\n\n/**\n * Session record for presence tracking.\n * Returned by sessions query.\n */\nexport const sessionValidator = v.object({\n\tclient: v.string(),\n\tdocument: v.string(),\n\tuser: v.optional(v.string()),\n\tprofile: v.optional(v.any()),\n\tcursor: v.optional(cursorValidator),\n\tseen: v.number(),\n});\n\n/**\n * Presence action (join or leave).\n * @deprecated Use sessionActionValidator instead\n */\nexport const presenceActionValidator = v.union(v.literal(\"join\"), v.literal(\"leave\"));\n\n// ============================================================================\n// New API Validators (Phase 1: signals.md migration)\n// ============================================================================\n\n/**\n * Replicate mutation type - combines insert/update/delete.\n */\nexport const replicateTypeValidator = v.union(\n\tv.literal(\"insert\"),\n\tv.literal(\"update\"),\n\tv.literal(\"delete\"),\n);\n\n/**\n * Session action - combines presence (join/leave) and mark (mark/signal).\n */\nexport const sessionActionValidator = v.union(\n\tv.literal(\"join\"),\n\tv.literal(\"leave\"),\n\tv.literal(\"mark\"),\n\tv.literal(\"signal\"),\n);\n\n// ============================================================================\n// Mutation Result Validators\n// ============================================================================\n\n/**\n * Standard success/seq result for insert/update/delete mutations.\n */\nexport const successSeqValidator = v.object({\n\tsuccess: v.boolean(),\n\tseq: v.number(),\n});\n\n/**\n * Compaction result with statistics.\n */\nexport const compactResultValidator = v.object({\n\tsuccess: v.boolean(),\n\tremoved: v.number(),\n\tretained: v.number(),\n\tsize: v.number(),\n});\n\n/**\n * Recovery query result with optional diff and state vector.\n */\nexport const recoveryResultValidator = v.object({\n\tdiff: v.optional(v.bytes()),\n\tvector: v.bytes(),\n});\n\n/**\n * Document state result (for SSR/hydration).\n */\nexport const documentStateValidator = v.union(\n\tv.object({\n\t\tbytes: v.bytes(),\n\t\tseq: v.number(),\n\t}),\n\tv.null(),\n);\n\n// ============================================================================\n// SSR/Material Validators\n// ============================================================================\n\n/**\n * SSR material query result (non-paginated, backward compatible).\n */\nexport const materialResultValidator = v.object({\n\tdocuments: v.any(),\n\tcount: v.number(),\n\tcrdt: v.optional(\n\t\tv.record(\n\t\t\tv.string(),\n\t\t\tv.object({\n\t\t\t\tbytes: v.bytes(),\n\t\t\t\tseq: v.number(),\n\t\t\t}),\n\t\t),\n\t),\n\tcursor: v.optional(v.number()),\n});\n\n// ============================================================================\n// Derived Types (Single Source of Truth)\n// ============================================================================\n\n/** User profile for presence/identity. */\nexport type Profile = Infer<typeof profileValidator>;\n\n/** Cursor position for collaborative editing. */\nexport type Cursor = Infer<typeof cursorValidator>;\n\n/** ProseMirror-compatible JSON structure. */\nexport type ProseValue = Infer<typeof proseValidator>;\n\n/** Individual stream change. */\nexport type StreamChange = Infer<typeof streamChangeValidator>;\n\n/** Stream change with exists flag. */\nexport type StreamChangeWithExists = Infer<typeof streamChangeWithExistsValidator>;\n\n/** Stream query result. */\nexport type StreamResult = Infer<typeof streamResultValidator>;\n\n/** Stream result with exists flags. */\nexport type StreamResultWithExists = Infer<typeof streamResultWithExistsValidator>;\n\n/** Session record for presence. */\nexport type Session = Infer<typeof sessionValidator>;\n\n/** Presence action type. */\nexport type PresenceAction = Infer<typeof presenceActionValidator>;\n\n/** Replicate mutation type. */\nexport type ReplicateType = Infer<typeof replicateTypeValidator>;\n\n/** Session action type. */\nexport type SessionAction = Infer<typeof sessionActionValidator>;\n\n/** Success/seq mutation result. */\nexport type SuccessSeq = Infer<typeof successSeqValidator>;\n\n/** Compaction result with stats. */\nexport type CompactResult = Infer<typeof compactResultValidator>;\n\n/** Recovery query result. */\nexport type RecoveryResult = Infer<typeof recoveryResultValidator>;\n\n/** Document state for SSR. */\nexport type DocumentState = Infer<typeof documentStateValidator>;\n\n/** SSR material result. */\nexport type MaterialResult = Infer<typeof materialResultValidator>;\n\n// ============================================================================\n// Additional Types (from types.ts)\n// ============================================================================\n\nexport interface FragmentValue {\n\t__xmlFragment: true;\n\tcontent?: XmlFragmentJSON;\n}\n\nexport interface XmlFragmentJSON {\n\ttype: \"doc\";\n\tcontent?: XmlNodeJSON[];\n}\n\nexport interface XmlNodeJSON {\n\ttype: string;\n\tattrs?: Record<string, unknown>;\n\tcontent?: XmlNodeJSON[];\n\ttext?: string;\n\tmarks?: { type: string; attrs?: Record<string, unknown> }[];\n}\n\n/** Operation type for streaming changes */\nexport enum OperationType {\n\tDelta = \"delta\",\n\tSnapshot = \"snapshot\",\n}\n\n/**\n * Extract prose field names from T (fields typed as ProseValue).\n * Used internally for type-safe prose field operations.\n */\nexport type ProseFields<T> = {\n\t[K in keyof T]: T[K] extends ProseValue ? K : never;\n}[keyof T];\n\n// ============================================================================\n// Duration Utilities\n// ============================================================================\n\ntype DurationUnit = \"m\" | \"h\" | \"d\";\nexport type Duration = `${number}${DurationUnit}`;\n\nexport interface CompactionConfig {\n\tthreshold?: number;\n\ttimeout?: Duration;\n\tretain?: number;\n}\n\nconst DURATION_MULTIPLIERS: Record<DurationUnit, number> = {\n\tm: 60_000,\n\th: 3_600_000,\n\td: 86_400_000,\n};\n\nexport function parseDuration(s: Duration): number {\n\tconst match = /^(\\d+)(m|h|d)$/i.exec(s);\n\tif (!match) throw new Error(`Invalid duration: ${s}`);\n\tconst [, num, unit] = match;\n\treturn parseInt(num) * DURATION_MULTIPLIERS[unit.toLowerCase() as DurationUnit];\n}\n\nexport { getLogger, type Logger } from \"./logger\";\n","import type { GenericMutationCtx, GenericQueryCtx, GenericDataModel } from \"convex/server\";\nimport { Replicate, type ViewFunction } from \"$/server\";\nimport type { CompactionConfig } from \"$/shared\";\n\nexport interface CollectionOptions<T extends object> {\n\tcompaction?: Partial<CompactionConfig>;\n\tview?: ViewFunction;\n\thooks?: {\n\t\tevalWrite?: (ctx: GenericMutationCtx<GenericDataModel>, doc: T) => void | Promise<void>;\n\t\tevalRemove?: (ctx: GenericMutationCtx<GenericDataModel>, docId: string) => void | Promise<void>;\n\t\tevalSession?: (\n\t\t\tctx: GenericMutationCtx<GenericDataModel>,\n\t\t\tclient: string,\n\t\t) => void | Promise<void>;\n\t\tonDelta?: (ctx: GenericQueryCtx<GenericDataModel>, result: any) => void | Promise<void>;\n\t\tonInsert?: (ctx: GenericMutationCtx<GenericDataModel>, doc: T) => void | Promise<void>;\n\t\tonUpdate?: (ctx: GenericMutationCtx<GenericDataModel>, doc: T) => void | Promise<void>;\n\t\tonRemove?: (ctx: GenericMutationCtx<GenericDataModel>, docId: string) => void | Promise<void>;\n\t\ttransform?: (docs: T[]) => T[] | Promise<T[]>;\n\t};\n}\n\nfunction createCollection<T extends object>(\n\tcomponent: any,\n\tname: string,\n\toptions?: CollectionOptions<T>,\n) {\n\treturn createCollectionInternal<T>(component, name, options);\n}\n\nexport const collection = {\n\tcreate: createCollection,\n} as const;\n\nfunction createCollectionInternal<T extends object>(\n\tcomponent: any,\n\tname: string,\n\toptions?: CollectionOptions<T>,\n) {\n\tconst storage = new Replicate<T>(component, name, options?.compaction);\n\n\tconst hooks = options?.hooks;\n\tconst view = options?.view;\n\n\treturn {\n\t\t__collection: name,\n\n\t\tmaterial: storage.createMaterialQuery({\n\t\t\tview,\n\t\t\ttransform: hooks?.transform,\n\t\t}),\n\n\t\tdelta: storage.createDeltaQuery({\n\t\t\tview,\n\t\t\tonDelta: hooks?.onDelta,\n\t\t}),\n\n\t\treplicate: storage.createReplicateMutation({\n\t\t\tevalWrite: hooks?.evalWrite,\n\t\t\tevalRemove: hooks?.evalRemove,\n\t\t\tonInsert: hooks?.onInsert,\n\t\t\tonUpdate: hooks?.onUpdate,\n\t\t\tonRemove: hooks?.onRemove,\n\t\t}),\n\n\t\tpresence: storage.createSessionMutation({\n\t\t\tview,\n\t\t\tevalSession: hooks?.evalSession,\n\t\t}),\n\n\t\tsession: storage.createSessionQuery({ view }),\n\t};\n}\n","import { defineTable } from \"convex/server\";\nimport { v } from \"convex/values\";\nimport { proseValidator } from \"$/shared\";\n\nexport interface ReplicationFields {\n\ttimestamp: number;\n}\n\nexport const prose = () => proseValidator;\n\n/**\n * Define a table with automatic timestamp field for replication.\n * All replicated tables must have an `id` field and define a `by_doc_id` index.\n *\n * @example\n * ```typescript\n * // convex/schema.ts\n * export default defineSchema({\n *   tasks: table(\n *     { id: v.string(), text: v.string(), isCompleted: v.boolean() },\n *     (t) => t.index('by_doc_id', ['id']).index('by_completed', ['isCompleted'])\n *   ),\n * });\n * ```\n */\nexport function table(userFields: Record<string, any>, applyIndexes?: (table: any) => any): any {\n\tconst tbl = defineTable({\n\t\t...userFields,\n\t\ttimestamp: v.number(),\n\t});\n\n\tif (applyIndexes) {\n\t\treturn applyIndexes(tbl);\n\t}\n\n\treturn tbl;\n}\n","/**\n * Migration System - Versioned Schemas with Auto-Diff\n *\n * Provides zero mental overhead migrations for local-first apps.\n * Users define versioned schemas, write server migrations,\n * and client migrations are generated automatically.\n */\n\nimport type { GenericValidator, Infer } from \"convex/values\";\nimport type { GenericMutationCtx, GenericDataModel } from \"convex/server\";\n\n// ─────────────────────────────────────────────────────────────────────────────\n// Schema Diff Types\n// ─────────────────────────────────────────────────────────────────────────────\n\n/** Field type for schema operations */\nexport type FieldType = \"string\" | \"number\" | \"boolean\" | \"null\" | \"array\" | \"object\" | \"prose\";\n\n/** Individual diff operation detected between schema versions */\nexport type SchemaDiffOperation =\n\t| { type: \"add_column\"; column: string; fieldType: FieldType; defaultValue: unknown }\n\t| { type: \"remove_column\"; column: string }\n\t| { type: \"rename_column\"; from: string; to: string }\n\t| { type: \"change_type\"; column: string; from: FieldType; to: FieldType };\n\n/** Result of diffing two schema versions */\nexport interface SchemaDiff {\n\tfromVersion: number;\n\ttoVersion: number;\n\toperations: SchemaDiffOperation[];\n\tisBackwardsCompatible: boolean;\n\tgeneratedSQL: string[];\n}\n\n// ─────────────────────────────────────────────────────────────────────────────\n// Migration Types\n// ─────────────────────────────────────────────────────────────────────────────\n\n/** Context passed to server migration functions */\nexport interface MigrationContext<DataModel extends GenericDataModel = GenericDataModel> {\n\tdb: GenericMutationCtx<DataModel>[\"db\"];\n}\n\n/** Single migration definition */\nexport interface MigrationDefinition<T = unknown> {\n\tname: string;\n\tbatchSize?: number;\n\tparallelize?: boolean;\n\tmigrate: (ctx: MigrationContext, doc: T) => Promise<void>;\n}\n\n/** Map of version numbers to migration definitions */\nexport type MigrationMap<T = unknown> = Record<number, MigrationDefinition<T>>;\n\n// ─────────────────────────────────────────────────────────────────────────────\n// Versioned Schema Types\n// ─────────────────────────────────────────────────────────────────────────────\n\n/** Options for schema.define() */\nexport interface SchemaDefinitionOptions<TShape extends GenericValidator> {\n\t/** Current schema version (increment when schema changes) */\n\tversion: number;\n\t/** Convex validator for the document shape */\n\tshape: TShape;\n\t/** Default values for optional fields (applied during migrations) */\n\tdefaults?: Partial<Infer<TShape>>;\n\t/** Previous schema versions for diffing */\n\thistory?: Record<number, GenericValidator>;\n}\n\n/** Versioned schema with migration capabilities */\nexport interface VersionedSchema<TShape extends GenericValidator> {\n\t/** Current schema version */\n\treadonly version: number;\n\t/** Convex validator for the document shape */\n\treadonly shape: TShape;\n\t/** Default values for optional fields */\n\treadonly defaults: Partial<Infer<TShape>>;\n\t/** Previous schema versions */\n\treadonly history: Record<number, GenericValidator>;\n\n\t/** Get validator for a specific version */\n\tgetVersion(version: number): GenericValidator;\n\n\t/** Compute diff between two versions */\n\tdiff(fromVersion: number, toVersion: number): SchemaDiff;\n\n\t/** Define server migrations for this schema */\n\tmigrations(definitions: MigrationMap<Infer<TShape>>): SchemaMigrations<TShape>;\n}\n\n/** Schema migrations wrapper */\nexport interface SchemaMigrations<TShape extends GenericValidator> {\n\t/** The versioned schema */\n\treadonly schema: VersionedSchema<TShape>;\n\t/** Migration definitions by version */\n\treadonly definitions: MigrationMap<Infer<TShape>>;\n}\n\n// ─────────────────────────────────────────────────────────────────────────────\n// Schema Diff Engine\n// ─────────────────────────────────────────────────────────────────────────────\n\n/**\n * Detect field type from a Convex validator.\n * This uses the validator's internal structure to determine the type.\n */\nfunction detectFieldType(validator: GenericValidator): FieldType {\n\tconst v = validator as { kind?: string; type?: string };\n\n\t// Check for prose validator (has specific structure)\n\tif (v.kind === \"object\") {\n\t\tconst inner = (validator as { fields?: Record<string, unknown> }).fields;\n\t\tif (inner && \"type\" in inner && \"content\" in inner) {\n\t\t\treturn \"prose\";\n\t\t}\n\t\treturn \"object\";\n\t}\n\n\tswitch (v.kind) {\n\t\tcase \"string\":\n\t\t\treturn \"string\";\n\t\tcase \"number\":\n\t\tcase \"float64\":\n\t\tcase \"int64\":\n\t\t\treturn \"number\";\n\t\tcase \"boolean\":\n\t\t\treturn \"boolean\";\n\t\tcase \"null\":\n\t\t\treturn \"null\";\n\t\tcase \"array\":\n\t\t\treturn \"array\";\n\t\tcase \"object\":\n\t\t\treturn \"object\";\n\t\tdefault:\n\t\t\treturn \"object\";\n\t}\n}\n\n/**\n * Extract field names from a Convex object validator.\n */\nfunction extractFields(validator: GenericValidator): Map<string, GenericValidator> {\n\tconst fields = new Map<string, GenericValidator>();\n\tconst v = validator as { kind?: string; fields?: Record<string, GenericValidator> };\n\n\tif (v.kind === \"object\" && v.fields) {\n\t\tfor (const [name, fieldValidator] of Object.entries(v.fields)) {\n\t\t\tfields.set(name, fieldValidator);\n\t\t}\n\t}\n\n\treturn fields;\n}\n\n/**\n * Map field type to SQLite type.\n */\nfunction fieldTypeToSQL(fieldType: FieldType): string {\n\tswitch (fieldType) {\n\t\tcase \"string\":\n\t\tcase \"prose\":\n\t\t\treturn \"TEXT\";\n\t\tcase \"number\":\n\t\t\treturn \"REAL\";\n\t\tcase \"boolean\":\n\t\t\treturn \"INTEGER\";\n\t\tcase \"null\":\n\t\t\treturn \"TEXT\";\n\t\tcase \"array\":\n\t\tcase \"object\":\n\t\t\treturn \"TEXT\"; // JSON stored as text\n\t\tdefault:\n\t\t\treturn \"TEXT\";\n\t}\n}\n\n/**\n * Escape SQL literal value.\n */\nfunction sqlLiteral(value: unknown): string {\n\tif (value === null || value === undefined) return \"NULL\";\n\tif (typeof value === \"string\") return `'${value.replace(/'/g, \"''\")}'`;\n\tif (typeof value === \"number\") return String(value);\n\tif (typeof value === \"boolean\") return value ? \"1\" : \"0\";\n\treturn `'${JSON.stringify(value).replace(/'/g, \"''\")}'`;\n}\n\n/**\n * Validate SQL identifier to prevent injection.\n */\nfunction validateIdentifier(name: string): string {\n\tif (!/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(name)) {\n\t\tthrow new Error(`Invalid SQL identifier: \"${name}\"`);\n\t}\n\treturn `\"${name}\"`;\n}\n\n/**\n * Compute the diff between two schema versions.\n */\nfunction computeSchemaDiff(\n\tfromValidator: GenericValidator,\n\ttoValidator: GenericValidator,\n\tfromVersion: number,\n\ttoVersion: number,\n\tdefaults: Record<string, unknown>,\n): SchemaDiff {\n\tconst operations: SchemaDiffOperation[] = [];\n\tconst generatedSQL: string[] = [];\n\n\tconst fromFields = extractFields(fromValidator);\n\tconst toFields = extractFields(toValidator);\n\n\t// Detect added fields\n\tfor (const [name, validator] of toFields) {\n\t\tif (!fromFields.has(name)) {\n\t\t\tconst fieldType = detectFieldType(validator);\n\t\t\tconst defaultValue = defaults[name];\n\n\t\t\toperations.push({\n\t\t\t\ttype: \"add_column\",\n\t\t\t\tcolumn: name,\n\t\t\t\tfieldType,\n\t\t\t\tdefaultValue,\n\t\t\t});\n\n\t\t\tconst sqlType = fieldTypeToSQL(fieldType);\n\t\t\tconst colName = validateIdentifier(name);\n\t\t\tconst def = defaultValue !== undefined ? ` DEFAULT ${sqlLiteral(defaultValue)}` : \"\";\n\t\t\tgeneratedSQL.push(`ALTER TABLE %TABLE% ADD COLUMN ${colName} ${sqlType}${def}`);\n\t\t}\n\t}\n\n\t// Detect removed fields\n\tfor (const [name] of fromFields) {\n\t\tif (!toFields.has(name)) {\n\t\t\toperations.push({\n\t\t\t\ttype: \"remove_column\",\n\t\t\t\tcolumn: name,\n\t\t\t});\n\n\t\t\tconst colName = validateIdentifier(name);\n\t\t\tgeneratedSQL.push(`ALTER TABLE %TABLE% DROP COLUMN ${colName}`);\n\t\t}\n\t}\n\n\t// Detect type changes (simplified - compares field types)\n\tfor (const [name, toFieldValidator] of toFields) {\n\t\tconst fromFieldValidator = fromFields.get(name);\n\t\tif (fromFieldValidator) {\n\t\t\tconst fromType = detectFieldType(fromFieldValidator);\n\t\t\tconst toType = detectFieldType(toFieldValidator);\n\t\t\tif (fromType !== toType) {\n\t\t\t\toperations.push({\n\t\t\t\t\ttype: \"change_type\",\n\t\t\t\t\tcolumn: name,\n\t\t\t\t\tfrom: fromType,\n\t\t\t\t\tto: toType,\n\t\t\t\t});\n\t\t\t\t// Type changes require custom migration\n\t\t\t}\n\t\t}\n\t}\n\n\t// Backwards compatible if only adding optional columns with defaults\n\tconst isBackwardsCompatible = operations.every(op => {\n\t\tif (op.type === \"add_column\") {\n\t\t\treturn op.defaultValue !== undefined;\n\t\t}\n\t\treturn false;\n\t});\n\n\treturn {\n\t\tfromVersion,\n\t\ttoVersion,\n\t\toperations,\n\t\tisBackwardsCompatible,\n\t\tgeneratedSQL,\n\t};\n}\n\n// ─────────────────────────────────────────────────────────────────────────────\n// schema.define() Implementation\n// ─────────────────────────────────────────────────────────────────────────────\n\n/**\n * Define a versioned schema with migration capabilities.\n *\n * @example\n * ```typescript\n * import { schema } from \"@trestleinc/replicate/server\";\n * import { v } from \"convex/values\";\n *\n * export const taskSchema = schema.define({\n *   version: 2,\n *   shape: v.object({\n *     id: v.string(),\n *     title: v.string(),\n *     priority: v.optional(v.string()),\n *     content: schema.prose(),\n *   }),\n *   defaults: {\n *     priority: \"medium\",\n *   },\n *   history: {\n *     1: v.object({\n *       id: v.string(),\n *       title: v.string(),\n *       content: schema.prose(),\n *     }),\n *   },\n * });\n * ```\n */\nexport function define<TShape extends GenericValidator>(\n\toptions: SchemaDefinitionOptions<TShape>,\n): VersionedSchema<TShape> {\n\tconst { version, shape, defaults = {}, history = {} } = options;\n\n\t// Store current version in history\n\tconst allVersions: Record<number, GenericValidator> = {\n\t\t...history,\n\t\t[version]: shape,\n\t};\n\n\tconst versionedSchema: VersionedSchema<TShape> = {\n\t\tversion,\n\t\tshape,\n\t\tdefaults: defaults as Partial<Infer<TShape>>,\n\t\thistory: allVersions,\n\n\t\tgetVersion(v: number): GenericValidator {\n\t\t\tconst validator = allVersions[v];\n\t\t\tif (!validator) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Schema version ${v} not found. Available: ${Object.keys(allVersions).join(\", \")}`,\n\t\t\t\t);\n\t\t\t}\n\t\t\treturn validator;\n\t\t},\n\n\t\tdiff(fromVersion: number, toVersion: number): SchemaDiff {\n\t\t\tconst fromValidator = this.getVersion(fromVersion);\n\t\t\tconst toValidator = this.getVersion(toVersion);\n\t\t\treturn computeSchemaDiff(\n\t\t\t\tfromValidator,\n\t\t\t\ttoValidator,\n\t\t\t\tfromVersion,\n\t\t\t\ttoVersion,\n\t\t\t\tdefaults as Record<string, unknown>,\n\t\t\t);\n\t\t},\n\n\t\tmigrations(definitions: MigrationMap<Infer<TShape>>): SchemaMigrations<TShape> {\n\t\t\treturn {\n\t\t\t\tschema: versionedSchema,\n\t\t\t\tdefinitions,\n\t\t\t};\n\t\t},\n\t};\n\n\treturn versionedSchema;\n}\n","/**\n * @trestleinc/replicate - Server exports\n *\n * Import from '@trestleinc/replicate/server' to use in Convex functions.\n */\n\nimport { v } from \"convex/values\";\nimport type {\n\tGenericMutationCtx,\n\tGenericQueryCtx,\n\tGenericDataModel,\n\tGenericTableInfo,\n\tQueryInitializer,\n\tOrderedQuery,\n\tQuery,\n} from \"convex/server\";\nimport { queryGeneric, mutationGeneric } from \"convex/server\";\nimport {\n\ttype CompactionConfig,\n\tparseDuration,\n\tprofileValidator,\n\tcursorValidator,\n\tstreamResultWithExistsValidator,\n\tsessionValidator,\n\tsuccessSeqValidator,\n\treplicateTypeValidator,\n\tsessionActionValidator,\n} from \"$/shared\";\n\n// ============================================================================\n// Re-exports\n// ============================================================================\n\nexport { collection } from \"$/server/collection\";\nexport type { CollectionOptions } from \"$/server/collection\";\n\n// Migration types\nexport type {\n\tFieldType,\n\tSchemaDiffOperation,\n\tSchemaDiff,\n\tMigrationContext,\n\tMigrationDefinition,\n\tMigrationMap,\n\tSchemaDefinitionOptions,\n\tVersionedSchema,\n\tSchemaMigrations,\n} from \"$/server/migration\";\n\nimport { table, prose } from \"$/server/schema\";\nimport { define } from \"$/server/migration\";\n\nexport const schema = {\n\ttable,\n\tprose,\n\tdefine,\n} as const;\n\n// ============================================================================\n// View Function Type\n// ============================================================================\n\n/** Query type returned by view functions - supports filter, order, collect, paginate */\ntype ViewQuery<TableInfo extends GenericTableInfo = GenericTableInfo> =\n\t| OrderedQuery<TableInfo>\n\t| Query<TableInfo>;\n\n/**\n * View function for filtering/ordering collection queries.\n * Receives a QueryInitializer and returns an OrderedQuery or Query.\n *\n * @example\n * ```typescript\n * view: async (ctx, q) => {\n *   const userId = await getAuthUserId(ctx);\n *   return q.filter(f => f.eq(f.field(\"ownerId\"), userId)).order(\"desc\");\n * }\n * ```\n */\nexport type ViewFunction<TableInfo extends GenericTableInfo = GenericTableInfo> = (\n\tctx: GenericQueryCtx<GenericDataModel>,\n\tquery: QueryInitializer<TableInfo>,\n) => ViewQuery<TableInfo> | Promise<ViewQuery<TableInfo>>;\n\n// ============================================================================\n// Replicate Class\n// ============================================================================\n\nconst DEFAULT_THRESHOLD = 500;\nconst DEFAULT_TIMEOUT_MS = 24 * 60 * 60 * 1000;\n\nexport class Replicate<T extends object> {\n\tprivate threshold: number;\n\tprivate timeout: number;\n\tprivate retain: number;\n\n\tconstructor(\n\t\tpublic component: any,\n\t\tpublic collectionName: string,\n\t\tcompaction?: Partial<CompactionConfig>,\n\t) {\n\t\tthis.threshold = compaction?.threshold ?? DEFAULT_THRESHOLD;\n\t\tthis.timeout = compaction?.timeout ? parseDuration(compaction.timeout) : DEFAULT_TIMEOUT_MS;\n\t\tthis.retain = compaction?.retain ?? 0;\n\t}\n\n\tcreateStreamQuery(opts?: {\n\t\tview?: ViewFunction;\n\t\tonStream?: (ctx: GenericQueryCtx<GenericDataModel>, result: any) => void | Promise<void>;\n\t}) {\n\t\tconst component = this.component;\n\t\tconst collection = this.collectionName;\n\n\t\treturn queryGeneric({\n\t\t\targs: {\n\t\t\t\tseq: v.number(),\n\t\t\t\tlimit: v.optional(v.number()),\n\t\t\t\tthreshold: v.optional(v.number()),\n\t\t\t},\n\t\t\treturns: streamResultWithExistsValidator,\n\t\t\thandler: async (ctx, args) => {\n\t\t\t\tconst result = await ctx.runQuery(component.mutations.stream, {\n\t\t\t\t\tcollection,\n\t\t\t\t\tseq: args.seq,\n\t\t\t\t\tlimit: args.limit,\n\t\t\t\t\tthreshold: args.threshold,\n\t\t\t\t});\n\n\t\t\t\tconst docIdSet = new Set<string>();\n\t\t\t\tfor (const change of result.changes) {\n\t\t\t\t\tdocIdSet.add((change as { document: string }).document);\n\t\t\t\t}\n\n\t\t\t\tconst existingDocs = new Set<string>();\n\n\t\t\t\tfor (const docId of docIdSet) {\n\t\t\t\t\tconst doc = await ctx.db\n\t\t\t\t\t\t.query(collection)\n\t\t\t\t\t\t.withIndex(\"by_doc_id\", (q: any) => q.eq(\"id\", docId))\n\t\t\t\t\t\t.first();\n\n\t\t\t\t\tif (!doc) continue;\n\n\t\t\t\t\tif (opts?.view) {\n\t\t\t\t\t\tconst viewQuery = await opts.view(ctx, ctx.db.query(collection));\n\t\t\t\t\t\tconst visible = await viewQuery.filter((q: any) => q.eq(q.field(\"id\"), docId)).first();\n\t\t\t\t\t\tif (visible) existingDocs.add(docId);\n\t\t\t\t\t} else {\n\t\t\t\t\t\texistingDocs.add(docId);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tinterface StreamChange {\n\t\t\t\t\tdocument: string;\n\t\t\t\t\tbytes: ArrayBuffer;\n\t\t\t\t\tseq: number;\n\t\t\t\t\ttype: string;\n\t\t\t\t}\n\t\t\t\tconst enrichedChanges = result.changes.map((c: StreamChange) => ({\n\t\t\t\t\t...c,\n\t\t\t\t\texists: existingDocs.has(c.document),\n\t\t\t\t}));\n\n\t\t\t\tconst enrichedResult = { ...result, changes: enrichedChanges };\n\n\t\t\t\tif (opts?.onStream) {\n\t\t\t\t\tawait opts.onStream(ctx, enrichedResult);\n\t\t\t\t}\n\n\t\t\t\treturn enrichedResult;\n\t\t\t},\n\t\t});\n\t}\n\n\tcreateMaterialQuery(opts?: {\n\t\tview?: ViewFunction;\n\t\ttransform?: (docs: T[]) => T[] | Promise<T[]>;\n\t}) {\n\t\tconst collection = this.collectionName;\n\n\t\treturn queryGeneric({\n\t\t\targs: {\n\t\t\t\tnumItems: v.optional(v.number()),\n\t\t\t\tcursor: v.optional(v.string()),\n\t\t\t},\n\t\t\treturns: v.any(),\n\t\t\thandler: async (ctx, args) => {\n\t\t\t\tconst query = opts?.view\n\t\t\t\t\t? await opts.view(ctx, ctx.db.query(collection))\n\t\t\t\t\t: ctx.db.query(collection).withIndex(\"by_timestamp\").order(\"desc\");\n\n\t\t\t\tif (args.numItems !== undefined) {\n\t\t\t\t\tconst result = await query.paginate({\n\t\t\t\t\t\tnumItems: args.numItems,\n\t\t\t\t\t\tcursor: args.cursor ?? null,\n\t\t\t\t\t});\n\n\t\t\t\t\tlet docs = result.page as T[];\n\t\t\t\t\tif (opts?.transform) {\n\t\t\t\t\t\tdocs = await opts.transform(docs);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn {\n\t\t\t\t\t\tpage: docs,\n\t\t\t\t\t\tisDone: result.isDone,\n\t\t\t\t\t\tcontinueCursor: result.continueCursor,\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\tlet docs = (await query.collect()) as T[];\n\t\t\t\tif (opts?.transform) {\n\t\t\t\t\tdocs = await opts.transform(docs);\n\t\t\t\t}\n\n\t\t\t\treturn {\n\t\t\t\t\tdocuments: docs,\n\t\t\t\t\tcount: docs.length,\n\t\t\t\t};\n\t\t\t},\n\t\t});\n\t}\n\n\tcreateInsertMutation(opts?: {\n\t\tevalWrite?: (ctx: GenericMutationCtx<GenericDataModel>, doc: T) => void | Promise<void>;\n\t\tonInsert?: (ctx: GenericMutationCtx<GenericDataModel>, doc: T) => void | Promise<void>;\n\t}) {\n\t\tconst component = this.component;\n\t\tconst collection = this.collectionName;\n\t\tconst { threshold, timeout, retain } = this;\n\n\t\treturn mutationGeneric({\n\t\t\targs: {\n\t\t\t\tdocument: v.string(),\n\t\t\t\tbytes: v.bytes(),\n\t\t\t\tmaterial: v.any(),\n\t\t\t},\n\t\t\treturns: successSeqValidator,\n\t\t\thandler: async (ctx, args) => {\n\t\t\t\tconst doc = args.material as T;\n\n\t\t\t\tif (opts?.evalWrite) {\n\t\t\t\t\tawait opts.evalWrite(ctx, doc);\n\t\t\t\t}\n\n\t\t\t\tawait ctx.db.insert(collection, {\n\t\t\t\t\tid: args.document,\n\t\t\t\t\t...(args.material as object),\n\t\t\t\t\ttimestamp: Date.now(),\n\t\t\t\t});\n\n\t\t\t\tconst result = await ctx.runMutation(component.mutations.insertDocument, {\n\t\t\t\t\tcollection,\n\t\t\t\t\tdocument: args.document,\n\t\t\t\t\tbytes: args.bytes,\n\t\t\t\t\tthreshold,\n\t\t\t\t\ttimeout,\n\t\t\t\t\tretain,\n\t\t\t\t});\n\n\t\t\t\tif (opts?.onInsert) {\n\t\t\t\t\tawait opts.onInsert(ctx, doc);\n\t\t\t\t}\n\n\t\t\t\treturn {\n\t\t\t\t\tsuccess: true,\n\t\t\t\t\tseq: result.seq,\n\t\t\t\t};\n\t\t\t},\n\t\t});\n\t}\n\n\tcreateUpdateMutation(opts?: {\n\t\tevalWrite?: (ctx: GenericMutationCtx<GenericDataModel>, doc: T) => void | Promise<void>;\n\t\tonUpdate?: (ctx: GenericMutationCtx<GenericDataModel>, doc: T) => void | Promise<void>;\n\t}) {\n\t\tconst component = this.component;\n\t\tconst collection = this.collectionName;\n\t\tconst { threshold, timeout, retain } = this;\n\n\t\treturn mutationGeneric({\n\t\t\targs: {\n\t\t\t\tdocument: v.string(),\n\t\t\t\tbytes: v.bytes(),\n\t\t\t\tmaterial: v.any(),\n\t\t\t},\n\t\t\treturns: successSeqValidator,\n\t\t\thandler: async (ctx, args) => {\n\t\t\t\tconst doc = args.material as T;\n\n\t\t\t\tif (opts?.evalWrite) {\n\t\t\t\t\tawait opts.evalWrite(ctx, doc);\n\t\t\t\t}\n\n\t\t\t\tconst existing = await ctx.db\n\t\t\t\t\t.query(collection)\n\t\t\t\t\t.withIndex(\"by_doc_id\", q => q.eq(\"id\", args.document))\n\t\t\t\t\t.first();\n\n\t\t\t\tif (existing) {\n\t\t\t\t\tawait ctx.db.patch(existing._id, {\n\t\t\t\t\t\t...(args.material as object),\n\t\t\t\t\t\ttimestamp: Date.now(),\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tconst result = await ctx.runMutation(component.mutations.updateDocument, {\n\t\t\t\t\tcollection,\n\t\t\t\t\tdocument: args.document,\n\t\t\t\t\tbytes: args.bytes,\n\t\t\t\t\tthreshold,\n\t\t\t\t\ttimeout,\n\t\t\t\t\tretain,\n\t\t\t\t});\n\n\t\t\t\tif (opts?.onUpdate) {\n\t\t\t\t\tawait opts.onUpdate(ctx, doc);\n\t\t\t\t}\n\n\t\t\t\treturn {\n\t\t\t\t\tsuccess: true,\n\t\t\t\t\tseq: result.seq,\n\t\t\t\t};\n\t\t\t},\n\t\t});\n\t}\n\n\tcreateRemoveMutation(opts?: {\n\t\tevalRemove?: (ctx: GenericMutationCtx<GenericDataModel>, docId: string) => void | Promise<void>;\n\t\tonRemove?: (ctx: GenericMutationCtx<GenericDataModel>, docId: string) => void | Promise<void>;\n\t}) {\n\t\tconst component = this.component;\n\t\tconst collection = this.collectionName;\n\t\tconst { threshold, timeout, retain } = this;\n\n\t\treturn mutationGeneric({\n\t\t\targs: {\n\t\t\t\tdocument: v.string(),\n\t\t\t\tbytes: v.bytes(),\n\t\t\t},\n\t\t\treturns: successSeqValidator,\n\t\t\thandler: async (ctx, args) => {\n\t\t\t\tif (opts?.evalRemove) {\n\t\t\t\t\tawait opts.evalRemove(ctx, args.document);\n\t\t\t\t}\n\n\t\t\t\tconst existing = await ctx.db\n\t\t\t\t\t.query(collection)\n\t\t\t\t\t.withIndex(\"by_doc_id\", q => q.eq(\"id\", args.document))\n\t\t\t\t\t.first();\n\n\t\t\t\tif (existing) {\n\t\t\t\t\tawait ctx.db.delete(existing._id);\n\t\t\t\t}\n\n\t\t\t\tconst result = await ctx.runMutation(component.mutations.deleteDocument, {\n\t\t\t\t\tcollection,\n\t\t\t\t\tdocument: args.document,\n\t\t\t\t\tbytes: args.bytes,\n\t\t\t\t\tthreshold,\n\t\t\t\t\ttimeout,\n\t\t\t\t\tretain,\n\t\t\t\t});\n\n\t\t\t\tif (opts?.onRemove) {\n\t\t\t\t\tawait opts.onRemove(ctx, args.document);\n\t\t\t\t}\n\n\t\t\t\treturn {\n\t\t\t\t\tsuccess: true,\n\t\t\t\t\tseq: result.seq,\n\t\t\t\t};\n\t\t\t},\n\t\t});\n\t}\n\n\tcreateMarkMutation(opts?: {\n\t\tevalWrite?: (ctx: GenericMutationCtx<GenericDataModel>, client: string) => void | Promise<void>;\n\t}) {\n\t\tconst component = this.component;\n\t\tconst collection = this.collectionName;\n\n\t\treturn mutationGeneric({\n\t\t\targs: {\n\t\t\t\tdocument: v.string(),\n\t\t\t\tclient: v.string(),\n\t\t\t\tseq: v.optional(v.number()),\n\t\t\t\tvector: v.optional(v.bytes()),\n\t\t\t},\n\t\t\treturns: v.null(),\n\t\t\thandler: async (ctx, args) => {\n\t\t\t\tif (opts?.evalWrite) {\n\t\t\t\t\tawait opts.evalWrite(ctx, args.client);\n\t\t\t\t}\n\n\t\t\t\tawait ctx.runMutation(component.mutations.mark, {\n\t\t\t\t\tcollection,\n\t\t\t\t\tdocument: args.document,\n\t\t\t\t\tclient: args.client,\n\t\t\t\t\tseq: args.seq,\n\t\t\t\t\tvector: args.vector,\n\t\t\t\t});\n\n\t\t\t\treturn null;\n\t\t\t},\n\t\t});\n\t}\n\n\tcreateReplicateMutation(opts?: {\n\t\tevalWrite?: (ctx: GenericMutationCtx<GenericDataModel>, doc: T) => void | Promise<void>;\n\t\tevalRemove?: (ctx: GenericMutationCtx<GenericDataModel>, docId: string) => void | Promise<void>;\n\t\tonInsert?: (ctx: GenericMutationCtx<GenericDataModel>, doc: T) => void | Promise<void>;\n\t\tonUpdate?: (ctx: GenericMutationCtx<GenericDataModel>, doc: T) => void | Promise<void>;\n\t\tonRemove?: (ctx: GenericMutationCtx<GenericDataModel>, docId: string) => void | Promise<void>;\n\t}) {\n\t\tconst component = this.component;\n\t\tconst collection = this.collectionName;\n\t\tconst { threshold, timeout, retain } = this;\n\n\t\treturn mutationGeneric({\n\t\t\targs: {\n\t\t\t\tdocument: v.string(),\n\t\t\t\tbytes: v.bytes(),\n\t\t\t\tmaterial: v.optional(v.any()),\n\t\t\t\ttype: replicateTypeValidator,\n\t\t\t},\n\t\t\treturns: successSeqValidator,\n\t\t\thandler: async (ctx, args) => {\n\t\t\t\tconst { document, bytes, material, type } = args;\n\n\t\t\t\tif (type === \"delete\") {\n\t\t\t\t\tif (opts?.evalRemove) {\n\t\t\t\t\t\tawait opts.evalRemove(ctx, document);\n\t\t\t\t\t}\n\n\t\t\t\t\tconst existing = await ctx.db\n\t\t\t\t\t\t.query(collection)\n\t\t\t\t\t\t.withIndex(\"by_doc_id\", q => q.eq(\"id\", document))\n\t\t\t\t\t\t.first();\n\n\t\t\t\t\tif (existing) {\n\t\t\t\t\t\tawait ctx.db.delete(existing._id);\n\t\t\t\t\t}\n\n\t\t\t\t\tconst result = await ctx.runMutation(component.mutations.deleteDocument, {\n\t\t\t\t\t\tcollection,\n\t\t\t\t\t\tdocument,\n\t\t\t\t\t\tbytes,\n\t\t\t\t\t\tthreshold,\n\t\t\t\t\t\ttimeout,\n\t\t\t\t\t\tretain,\n\t\t\t\t\t});\n\n\t\t\t\t\tif (opts?.onRemove) {\n\t\t\t\t\t\tawait opts.onRemove(ctx, document);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn { success: true, seq: result.seq };\n\t\t\t\t}\n\n\t\t\t\tconst doc = material as T;\n\t\t\t\tif (opts?.evalWrite) {\n\t\t\t\t\tawait opts.evalWrite(ctx, doc);\n\t\t\t\t}\n\n\t\t\t\tif (type === \"insert\") {\n\t\t\t\t\tawait ctx.db.insert(collection, {\n\t\t\t\t\t\tid: document,\n\t\t\t\t\t\t...(material as object),\n\t\t\t\t\t\ttimestamp: Date.now(),\n\t\t\t\t\t});\n\n\t\t\t\t\tconst result = await ctx.runMutation(component.mutations.insertDocument, {\n\t\t\t\t\t\tcollection,\n\t\t\t\t\t\tdocument,\n\t\t\t\t\t\tbytes,\n\t\t\t\t\t\tthreshold,\n\t\t\t\t\t\ttimeout,\n\t\t\t\t\t\tretain,\n\t\t\t\t\t});\n\n\t\t\t\t\tif (opts?.onInsert) {\n\t\t\t\t\t\tawait opts.onInsert(ctx, doc);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn { success: true, seq: result.seq };\n\t\t\t\t}\n\n\t\t\t\tconst existing = await ctx.db\n\t\t\t\t\t.query(collection)\n\t\t\t\t\t.withIndex(\"by_doc_id\", q => q.eq(\"id\", document))\n\t\t\t\t\t.first();\n\n\t\t\t\tif (existing) {\n\t\t\t\t\tawait ctx.db.patch(existing._id, {\n\t\t\t\t\t\t...(material as object),\n\t\t\t\t\t\ttimestamp: Date.now(),\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tconst result = await ctx.runMutation(component.mutations.updateDocument, {\n\t\t\t\t\tcollection,\n\t\t\t\t\tdocument,\n\t\t\t\t\tbytes,\n\t\t\t\t\tthreshold,\n\t\t\t\t\ttimeout,\n\t\t\t\t\tretain,\n\t\t\t\t});\n\n\t\t\t\tif (opts?.onUpdate) {\n\t\t\t\t\tawait opts.onUpdate(ctx, doc);\n\t\t\t\t}\n\n\t\t\t\treturn { success: true, seq: result.seq };\n\t\t\t},\n\t\t});\n\t}\n\n\tcreateSessionMutation(opts?: {\n\t\tview?: ViewFunction;\n\t\tevalSession?: (\n\t\t\tctx: GenericMutationCtx<GenericDataModel>,\n\t\t\tclient: string,\n\t\t) => void | Promise<void>;\n\t}) {\n\t\tconst component = this.component;\n\t\tconst collection = this.collectionName;\n\n\t\treturn mutationGeneric({\n\t\t\targs: {\n\t\t\t\tdocument: v.string(),\n\t\t\t\tclient: v.string(),\n\t\t\t\taction: sessionActionValidator,\n\t\t\t\tuser: v.optional(v.string()),\n\t\t\t\tprofile: v.optional(profileValidator),\n\t\t\t\tcursor: v.optional(cursorValidator),\n\t\t\t\tinterval: v.optional(v.number()),\n\t\t\t\tvector: v.optional(v.bytes()),\n\t\t\t\tseq: v.optional(v.number()),\n\t\t\t},\n\t\t\treturns: v.null(),\n\t\t\thandler: async (ctx, args) => {\n\t\t\t\tif (opts?.view) {\n\t\t\t\t\tconst viewQuery = await opts.view(ctx as any, ctx.db.query(collection));\n\t\t\t\t\tconst canAccess = await viewQuery\n\t\t\t\t\t\t.filter((q: any) => q.eq(q.field(\"id\"), args.document))\n\t\t\t\t\t\t.first();\n\t\t\t\t\tif (!canAccess) {\n\t\t\t\t\t\t// Silently return for unauthorized documents (e.g., stale cached docs after logout)\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (opts?.evalSession) {\n\t\t\t\t\tawait opts.evalSession(ctx, args.client);\n\t\t\t\t}\n\n\t\t\t\tconst { action, document, client, user, profile, cursor, interval, vector, seq } = args;\n\n\t\t\t\tif (action === \"mark\") {\n\t\t\t\t\tawait ctx.runMutation(component.mutations.mark, {\n\t\t\t\t\t\tcollection,\n\t\t\t\t\t\tdocument,\n\t\t\t\t\t\tclient,\n\t\t\t\t\t\tseq,\n\t\t\t\t\t\tvector,\n\t\t\t\t\t});\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\t\t\t\tif (action === \"signal\") {\n\t\t\t\t\tif (seq !== undefined || vector !== undefined) {\n\t\t\t\t\t\tawait ctx.runMutation(component.mutations.mark, {\n\t\t\t\t\t\t\tcollection,\n\t\t\t\t\t\t\tdocument,\n\t\t\t\t\t\t\tclient,\n\t\t\t\t\t\t\tseq,\n\t\t\t\t\t\t\tvector,\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\n\t\t\t\t\tawait ctx.runMutation(component.mutations.presence, {\n\t\t\t\t\t\tcollection,\n\t\t\t\t\t\tdocument,\n\t\t\t\t\t\tclient,\n\t\t\t\t\t\taction: \"join\",\n\t\t\t\t\t\tuser,\n\t\t\t\t\t\tprofile,\n\t\t\t\t\t\tcursor,\n\t\t\t\t\t\tinterval,\n\t\t\t\t\t\tvector,\n\t\t\t\t\t});\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\t\t\t\tconst presenceAction = action === \"join\" || action === \"leave\" ? action : \"join\";\n\t\t\t\tawait ctx.runMutation(component.mutations.presence, {\n\t\t\t\t\tcollection,\n\t\t\t\t\tdocument,\n\t\t\t\t\tclient,\n\t\t\t\t\taction: presenceAction,\n\t\t\t\t\tuser,\n\t\t\t\t\tprofile,\n\t\t\t\t\tcursor,\n\t\t\t\t\tinterval,\n\t\t\t\t\tvector,\n\t\t\t\t});\n\n\t\t\t\treturn null;\n\t\t\t},\n\t\t});\n\t}\n\n\tcreateDeltaQuery(opts?: {\n\t\tview?: ViewFunction;\n\t\tonDelta?: (ctx: GenericQueryCtx<GenericDataModel>, result: any) => void | Promise<void>;\n\t}) {\n\t\tconst component = this.component;\n\t\tconst collection = this.collectionName;\n\n\t\treturn queryGeneric({\n\t\t\targs: {\n\t\t\t\tseq: v.optional(v.number()),\n\t\t\t\tlimit: v.optional(v.number()),\n\t\t\t\tthreshold: v.optional(v.number()),\n\t\t\t\tdocument: v.optional(v.string()),\n\t\t\t\tvector: v.optional(v.bytes()),\n\t\t\t},\n\t\t\treturns: v.any(),\n\t\t\thandler: async (ctx, args) => {\n\t\t\t\tif (args.vector !== undefined && args.document === undefined) {\n\t\t\t\t\tthrow new Error(\"'document' is required when 'vector' is provided\");\n\t\t\t\t}\n\n\t\t\t\tif (args.vector !== undefined && args.document !== undefined) {\n\t\t\t\t\tconst recoveryResult = await ctx.runQuery(component.mutations.recovery, {\n\t\t\t\t\t\tcollection,\n\t\t\t\t\t\tdocument: args.document,\n\t\t\t\t\t\tvector: args.vector,\n\t\t\t\t\t});\n\t\t\t\t\treturn { mode: \"recovery\" as const, ...recoveryResult };\n\t\t\t\t}\n\n\t\t\t\tconst result = await ctx.runQuery(component.mutations.stream, {\n\t\t\t\t\tcollection,\n\t\t\t\t\tseq: args.seq ?? 0,\n\t\t\t\t\tlimit: args.limit,\n\t\t\t\t\tthreshold: args.threshold,\n\t\t\t\t});\n\n\t\t\t\tconst docIdSet = new Set<string>();\n\t\t\t\tfor (const change of result.changes) {\n\t\t\t\t\tdocIdSet.add((change as { document: string }).document);\n\t\t\t\t}\n\n\t\t\t\tconst existingDocs = new Set<string>();\n\n\t\t\t\tfor (const docId of docIdSet) {\n\t\t\t\t\tconst doc = await ctx.db\n\t\t\t\t\t\t.query(collection)\n\t\t\t\t\t\t.withIndex(\"by_doc_id\", (q: any) => q.eq(\"id\", docId))\n\t\t\t\t\t\t.first();\n\n\t\t\t\t\tif (!doc) continue;\n\n\t\t\t\t\tif (opts?.view) {\n\t\t\t\t\t\tconst viewQuery = await opts.view(ctx, ctx.db.query(collection));\n\t\t\t\t\t\tconst visible = await viewQuery.filter((q: any) => q.eq(q.field(\"id\"), docId)).first();\n\t\t\t\t\t\tif (visible) existingDocs.add(docId);\n\t\t\t\t\t} else {\n\t\t\t\t\t\texistingDocs.add(docId);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tinterface StreamChange {\n\t\t\t\t\tdocument: string;\n\t\t\t\t\tbytes: ArrayBuffer;\n\t\t\t\t\tseq: number;\n\t\t\t\t\ttype: string;\n\t\t\t\t}\n\t\t\t\tconst enrichedChanges = result.changes.map((c: StreamChange) => ({\n\t\t\t\t\t...c,\n\t\t\t\t\texists: existingDocs.has(c.document),\n\t\t\t\t}));\n\n\t\t\t\tconst enrichedResult = { mode: \"stream\" as const, ...result, changes: enrichedChanges };\n\n\t\t\t\tif (opts?.onDelta) {\n\t\t\t\t\tawait opts.onDelta(ctx, enrichedResult);\n\t\t\t\t}\n\n\t\t\t\treturn enrichedResult;\n\t\t\t},\n\t\t});\n\t}\n\n\tcreateSessionQuery(opts?: { view?: ViewFunction }) {\n\t\tconst component = this.component;\n\t\tconst collection = this.collectionName;\n\n\t\treturn queryGeneric({\n\t\t\targs: {\n\t\t\t\tdocument: v.string(),\n\t\t\t\tconnected: v.optional(v.boolean()),\n\t\t\t\texclude: v.optional(v.string()),\n\t\t\t},\n\t\t\treturns: v.array(sessionValidator),\n\t\t\thandler: async (ctx, args) => {\n\t\t\t\tif (opts?.view) {\n\t\t\t\t\tconst viewQuery = await opts.view(ctx, ctx.db.query(collection));\n\t\t\t\t\tconst canAccess = await viewQuery\n\t\t\t\t\t\t.filter((q: any) => q.eq(q.field(\"id\"), args.document))\n\t\t\t\t\t\t.first();\n\t\t\t\t\tif (!canAccess) {\n\t\t\t\t\t\t// Return empty sessions for unauthorized documents\n\t\t\t\t\t\treturn [];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn await ctx.runQuery(component.mutations.sessions, {\n\t\t\t\t\tcollection,\n\t\t\t\t\tdocument: args.document,\n\t\t\t\t\tconnected: args.connected,\n\t\t\t\t\texclude: args.exclude,\n\t\t\t\t});\n\t\t\t},\n\t\t});\n\t}\n}\n"],"mappings":"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"}